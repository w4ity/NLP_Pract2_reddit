subreddit,text,fecha,tokens
Python,I am more excited for installing dependency groups than someone should really be.,2025-04-26T19:58:42,"['excited', 'installing', 'dependency', 'group', 'someone', 'really']"
Python,"Sorry if this is a dumb question — what’s the difference between this dependency groups feature and  ‘pip install myproject[tests,dev]’",2025-04-26T23:35:58,"['sorry', 'dumb', 'question', '—', 'what’s', 'difference', 'dependency', 'group', 'feature', '‘pip', 'install', 'myprojecttestsdev’']"
Python,Excited about `pip index versions --json`!,2025-04-26T20:48:51,"['excited', 'pip', 'index', 'version', 'json']"
Python,All of my hopes and dreams are invested in uv now.,2025-04-26T23:45:37,"['hope', 'dream', 'invested', 'uv']"
Python,"Kind of cool to see the Home Assistant reference :)

When I saw that progress bar, I thought “I’ve seen that before.” Sure enough, they’re using rich to display it. 

I’d like to make a joke about installing uv looking so much better now, but maybe there’s a chance that pip will fold uv in, and adopt it.",2025-04-26T21:51:51,"['kind', 'cool', 'see', 'home', 'assistant', 'reference', 'saw', 'progress', 'bar', 'thought', '“i’ve', 'seen', 'before”', 'sure', 'enough', 'they’re', 'using', 'rich', 'display', 'i’d', 'like', 'make', 'joke', 'installing', 'uv', 'looking', 'much', 'better', 'maybe', 'there’s', 'chance', 'pip', 'fold', 'uv', 'adopt']"
Python,Is it possible to specify required dependency groups for an item within a requirements.txt file?,2025-04-26T23:05:41,"['possible', 'specify', 'required', 'dependency', 'group', 'item', 'within', 'requirementstxt', 'file']"
Python,"I’ve only recently started using dependency groups (through uv). They are so much better than using multiple requirements files, but I still haven’t gotten good at really using them and organizing them well. But I am confident that I will.",2025-04-26T23:36:09,"['i’ve', 'recently', 'started', 'using', 'dependency', 'group', 'uv', 'much', 'better', 'using', 'multiple', 'requirement', 'file', 'still', 'haven’t', 'gotten', 'good', 'really', 'using', 'organizing', 'well', 'confident']"
Python,pip is the new Internet Explorer. Just pip install uv,2025-04-26T20:49:32,"['pip', 'new', 'internet', 'explorer', 'pip', 'install', 'uv']"
Python,What's the use-case of pip now that there is uv? are there features not yet reimplemented by uv?,2025-04-27T06:55:45,"['whats', 'usecase', 'pip', 'uv', 'feature', 'yet', 'reimplemented', 'uv']"
Python,"numba.njit for a numpy array transformation i did not know how to do using the built-in operations. Was about 200x faster (it went from the bottleneck to negligeable).

numba.njit is VERY good for these short, single function, math-heavy compiles. No need to change anything in your pipeline, debugging is okay, you can just disable the decorator and go back to python for testing stuff.

For anything small-scale its my go-to.",2025-04-25T12:59:27,"['numbanjit', 'numpy', 'array', 'transformation', 'know', 'using', 'builtin', 'operation', '200x', 'faster', 'went', 'bottleneck', 'negligeable', 'numbanjit', 'good', 'short', 'single', 'function', 'mathheavy', 'compiles', 'need', 'change', 'anything', 'pipeline', 'debugging', 'okay', 'disable', 'decorator', 'go', 'back', 'python', 'testing', 'stuff', 'anything', 'smallscale', 'goto']"
Python,"This is pretty much all I do at my job. I have extensively used Cython, Numba, C/C++ extensions, llvmlite.

If used correctly, all of them will achieve same performance. IMO, it is more about ease of use.

Numba works very well when the operation you want to speed-up is rather trivial.

For a little more complex things, Cython is good. Cython sometimes makes the job harder instead. For eg., templated logic is hard in Cython. Fused type support is also lackluster IMO.

C/C++ extensions basically gives you super powers but they are a pain in the ass to write. Especially, dealing with CPython API is pain. Boilerplate code also increases rather easily with pure C/C++ extensions.

For most task, I have found C/C++ code wrapped up in Cython works best.

I have used llvmlite, but that is reserved for most performance sensitive code, where we may want to JIT compile some operation for a specific type (or a combination of types in real usage).",2025-04-25T13:47:00,"['pretty', 'much', 'job', 'extensively', 'used', 'cython', 'numba', 'cc', 'extension', 'llvmlite', 'used', 'correctly', 'achieve', 'performance', 'imo', 'ease', 'use', 'numba', 'work', 'well', 'operation', 'want', 'speedup', 'rather', 'trivial', 'little', 'complex', 'thing', 'cython', 'good', 'cython', 'sometimes', 'make', 'job', 'harder', 'instead', 'eg', 'templated', 'logic', 'hard', 'cython', 'fused', 'type', 'support', 'also', 'lackluster', 'imo', 'cc', 'extension', 'basically', 'give', 'super', 'power', 'pain', 'as', 'write', 'especially', 'dealing', 'cpython', 'api', 'pain', 'boilerplate', 'code', 'also', 'increase', 'rather', 'easily', 'pure', 'cc', 'extension', 'task', 'found', 'cc', 'code', 'wrapped', 'cython', 'work', 'best', 'used', 'llvmlite', 'reserved', 'performance', 'sensitive', 'code', 'may', 'want', 'jit', 'compile', 'operation', 'specific', 'type', 'combination', 'type', 'real', 'usage']"
Python,"I've written some bindings for my C++ library with nanobind.

Integration was trivial as I automated binding of classes with roughly 150 lines of code.

I don't have a performance comparison as this is for a CPU bound problem, so I never considered implementing it in Python to begin with.",2025-04-25T13:10:02,"['ive', 'written', 'binding', 'c', 'library', 'nanobind', 'integration', 'trivial', 'automated', 'binding', 'class', 'roughly', '150', 'line', 'code', 'dont', 'performance', 'comparison', 'cpu', 'bound', 'problem', 'never', 'considered', 'implementing', 'python', 'begin']"
Python,"I am writing a N-body gravity simulation library. It was written in python but overtime the whole code base is rewritten in c with a python wrapper. The speed improvement from vectorised NumPy to C is 50x to 100x.

It is not particularly difficult to maintain since I am just writing in plain C. In fact, my library can even be used without python, but having a python wrapper is quite nice. All I need to do in Python is to load the c dynamic-link library with ctypes.cdll.",2025-04-25T13:12:33,"['writing', 'nbody', 'gravity', 'simulation', 'library', 'written', 'python', 'overtime', 'whole', 'code', 'base', 'rewritten', 'c', 'python', 'wrapper', 'speed', 'improvement', 'vectorised', 'numpy', 'c', '50x', '100x', 'particularly', 'difficult', 'maintain', 'since', 'writing', 'plain', 'c', 'fact', 'library', 'even', 'used', 'without', 'python', 'python', 'wrapper', 'quite', 'nice', 'need', 'python', 'load', 'c', 'dynamiclink', 'library', 'ctypescdll']"
Python,"I implemented a bunch of numerics code in Rust (broadly speaking mathematical optimization, computational geometry, signal processing). The issues in python were performance on the one hand (think low level ""number crunching""), but also correctness (for example with a quite intricate dynamic program with plenty of places to ""go slightly wrong"").

The project I'm currently working on is basically ""pure"" mathematical programming around a problem involving order statistics etc. for very large datasets. The base algorithms needed to implement that are either not available in python or incur full copies of the full dataset that have to (and can) be avoided. Rust also enables the low level control over memory needed for such problems.

>What tool did you choose and why?

Rust, because it's a great language with great tooling. C has the same correctness problems as Python would have and writing and integrating C extensions kind of sucks, lol no to fortran etc., and I don't know Cython (and don't think it'd be a great experience for me personally).

Specifically I use [maturin](https://github.com/PyO3/maturin) with [pyo3](https://github.com/PyO3/pyo3), although I'd try using [uniffi](https://github.com/mozilla/uniffi-rs) for my next project (because I don't actually need a complicated API for my library).

>What kind of speedup did you observe?

It doesn't really make sense to speak of a speedup for me personally, since the kind of stuff I write currently tends to go from ""completely infeasible"" to ""can be done"". 

>How was the integration process—setup, debugging, maintenance?

setup is trivial, maintenance depends on your API surface, what exactly you want to do, what you change, what sort of dependencies you have etc. Debugging also depends on how you do things. I tend to implement everything in rust and then have the python API be a ""consumer"" of the rust API, which means that debugging is just debugging a rust project.

>In hindsight, would you do it the same way again? 

Yes, in fact I have done it this way for quite a few projects at this point and love it.",2025-04-25T13:27:56,"['implemented', 'bunch', 'numerics', 'code', 'rust', 'broadly', 'speaking', 'mathematical', 'optimization', 'computational', 'geometry', 'signal', 'processing', 'issue', 'python', 'performance', 'one', 'hand', 'think', 'low', 'level', 'number', 'crunching', 'also', 'correctness', 'example', 'quite', 'intricate', 'dynamic', 'program', 'plenty', 'place', 'go', 'slightly', 'wrong', 'project', 'im', 'currently', 'working', 'basically', 'pure', 'mathematical', 'programming', 'around', 'problem', 'involving', 'order', 'statistic', 'etc', 'large', 'datasets', 'base', 'algorithm', 'needed', 'implement', 'either', 'available', 'python', 'incur', 'full', 'copy', 'full', 'dataset', 'avoided', 'rust', 'also', 'enables', 'low', 'level', 'control', 'memory', 'needed', 'problem', 'tool', 'choose', 'rust', 'great', 'language', 'great', 'tooling', 'c', 'correctness', 'problem', 'python', 'would', 'writing', 'integrating', 'c', 'extension', 'kind', 'suck', 'lol', 'fortran', 'etc', 'dont', 'know', 'cython', 'dont', 'think', 'itd', 'great', 'experience', 'personally', 'specifically', 'use', 'maturin', 'pyo3', 'although', 'id', 'try', 'using', 'uniffi', 'next', 'project', 'dont', 'actually', 'need', 'complicated', 'api', 'library', 'kind', 'speedup', 'observe', 'doesnt', 'really', 'make', 'sense', 'speak', 'speedup', 'personally', 'since', 'kind', 'stuff', 'write', 'currently', 'tends', 'go', 'completely', 'infeasible', 'done', 'integration', 'process—setup', 'debugging', 'maintenance', 'setup', 'trivial', 'maintenance', 'depends', 'api', 'surface', 'exactly', 'want', 'change', 'sort', 'dependency', 'etc', 'debugging', 'also', 'depends', 'thing', 'tend', 'implement', 'everything', 'rust', 'python', 'api', 'consumer', 'rust', 'api', 'mean', 'debugging', 'debugging', 'rust', 'project', 'hindsight', 'would', 'way', 'yes', 'fact', 'done', 'way', 'quite', 'project', 'point', 'love']"
Python,"I maintain several OSS packages that use a mix of C++ and Python or Numba. Python bindings for C++ code are handwritten with pybind11. Here are my experiences:

If you can, use Numba. It is as fast as well-written C++ or Rust code. Behind the scenes your code is compiled into optimized machine code with LLVM. Maintenance is so much easier, because all your code is still Python and you don't have to make binary wheels during deployment (this is a huge hassle to set up).

If Numba doesn't work for you (your program's runtime is not dominated by isolated hot code paths), use Rust or C++, don't write code in C. In Rust or C++, you'll have automated life-time management and type conversion (from native Python to native compiled language and vice versa), which in C, you have to code yourself, which is error prone, brittle, and requires large amounts of boilerplate.

A note on automatic binding generators. There are tools which claim that they can generate the bindings for you automatically. You can use these as a starting point, but they cannot do the job properly unless you have a trivial code base. Tools cannot guess how object ownership should be handled performantly case-by-case (often you want to avoid copying data, so you want to share ownership intelligently between the Python side and the compiled side), and the interfaces they generate won't be pythonic. If you care about performance and API design, you want to have full control over the language boundary, so you should write the bindings manually.

Now if you want to deploy your package to users, you need to set up your project so that the code is compiled on a \`pip install\`. This means you have to integrate with a foreign build system like CMake. Once you figured that out, you can then just ship a sdist package, but that's bad, people need the right compiler on their local machine to use your package, and installing may take a lot of time. The user-friendly way is to generate the wheels for them using a CI/CD pipeline. Doing that correctly for Windows, Linux, and MacOS is a hard problem, fortunately, the package cibuildwheel exists, which greatly simplifies the process.

Some things I'd advice against:

\- Cython: clunky, because you need to learn a domain-specific language that is not well documented, only works well with C code (but see issues with C code), C++ support is bad

\- Swig: You don't want to pull in a separate parsing program for your language (only works well for C, not C++ last time I checked - which was a few years ago).

Update: I see that nanobind is the successor to pybind11 and written by the same author, so new projects should use nanobind instead of pybind11.",2025-04-25T15:02:22,"['maintain', 'several', 'os', 'package', 'use', 'mix', 'c', 'python', 'numba', 'python', 'binding', 'c', 'code', 'handwritten', 'pybind11', 'experience', 'use', 'numba', 'fast', 'wellwritten', 'c', 'rust', 'code', 'behind', 'scene', 'code', 'compiled', 'optimized', 'machine', 'code', 'llvm', 'maintenance', 'much', 'easier', 'code', 'still', 'python', 'dont', 'make', 'binary', 'wheel', 'deployment', 'huge', 'hassle', 'set', 'numba', 'doesnt', 'work', 'program', 'runtime', 'dominated', 'isolated', 'hot', 'code', 'path', 'use', 'rust', 'c', 'dont', 'write', 'code', 'c', 'rust', 'c', 'youll', 'automated', 'lifetime', 'management', 'type', 'conversion', 'native', 'python', 'native', 'compiled', 'language', 'vice', 'versa', 'c', 'code', 'error', 'prone', 'brittle', 'requires', 'large', 'amount', 'boilerplate', 'note', 'automatic', 'binding', 'generator', 'tool', 'claim', 'generate', 'binding', 'automatically', 'use', 'starting', 'point', 'cannot', 'job', 'properly', 'unless', 'trivial', 'code', 'base', 'tool', 'cannot', 'guess', 'object', 'ownership', 'handled', 'performantly', 'casebycase', 'often', 'want', 'avoid', 'copying', 'data', 'want', 'share', 'ownership', 'intelligently', 'python', 'side', 'compiled', 'side', 'interface', 'generate', 'wont', 'pythonic', 'care', 'performance', 'api', 'design', 'want', 'full', 'control', 'language', 'boundary', 'write', 'binding', 'manually', 'want', 'deploy', 'package', 'user', 'need', 'set', 'project', 'code', 'compiled', 'pip', 'install', 'mean', 'integrate', 'foreign', 'build', 'system', 'like', 'cmake', 'figured', 'ship', 'sdist', 'package', 'thats', 'bad', 'people', 'need', 'right', 'compiler', 'local', 'machine', 'use', 'package', 'installing', 'may', 'take', 'lot', 'time', 'userfriendly', 'way', 'generate', 'wheel', 'using', 'cicd', 'pipeline', 'correctly', 'window', 'linux', 'macos', 'hard', 'problem', 'fortunately', 'package', 'cibuildwheel', 'exists', 'greatly', 'simplifies', 'process', 'thing', 'id', 'advice', 'cython', 'clunky', 'need', 'learn', 'domainspecific', 'language', 'well', 'documented', 'work', 'well', 'c', 'code', 'see', 'issue', 'c', 'code', 'c', 'support', 'bad', 'swig', 'dont', 'want', 'pull', 'separate', 'parsing', 'program', 'language', 'work', 'well', 'c', 'c', 'last', 'time', 'checked', 'year', 'ago', 'update', 'see', 'nanobind', 'successor', 'pybind11', 'written', 'author', 'new', 'project', 'use', 'nanobind', 'instead', 'pybind11']"
Python,"I've done a bit of this. From the hobby side of things, I worked on a Python game engine. Bits of code like the collision detection subsystem are performance critical and must run on CPU every game loop. It's difficult to write those algorithms with simple vectorized functions so it made sense to do it in C. Used Cython to create the Python bindings. Data inputs were numpy arrays. The way you interoperate is to use numpy headers to directly access memory pointers from numpy array Python objects. Trying to use Cython's various built-in methods for fetching that pointer were all way too slow, for whatever reason. In a game loop, you really need things to be happening much faster than 1e-5 seconds. The most safety checking I did was checking array flags (is it c_contiguous? Etc).

Also required a few external C libs and loaded those with ctypes. IMO, ctypes is a god send if you need c libraries and don't particularly care about speed. For a game engine that means these calls aren't happening every game loop (every frame). So a huge amount of supporting code could potentially be ctypes imports.

That's not the only project where I've used those tools, just the most recent.",2025-04-25T13:28:58,"['ive', 'done', 'bit', 'hobby', 'side', 'thing', 'worked', 'python', 'game', 'engine', 'bit', 'code', 'like', 'collision', 'detection', 'subsystem', 'performance', 'critical', 'must', 'run', 'cpu', 'every', 'game', 'loop', 'difficult', 'write', 'algorithm', 'simple', 'vectorized', 'function', 'made', 'sense', 'c', 'used', 'cython', 'create', 'python', 'binding', 'data', 'input', 'numpy', 'array', 'way', 'interoperate', 'use', 'numpy', 'header', 'directly', 'access', 'memory', 'pointer', 'numpy', 'array', 'python', 'object', 'trying', 'use', 'cythons', 'various', 'builtin', 'method', 'fetching', 'pointer', 'way', 'slow', 'whatever', 'reason', 'game', 'loop', 'really', 'need', 'thing', 'happening', 'much', 'faster', '1e5', 'second', 'safety', 'checking', 'checking', 'array', 'flag', 'ccontiguous', 'etc', 'also', 'required', 'external', 'c', 'libs', 'loaded', 'ctypes', 'imo', 'ctypes', 'god', 'send', 'need', 'c', 'library', 'dont', 'particularly', 'care', 'speed', 'game', 'engine', 'mean', 'call', 'arent', 'happening', 'every', 'game', 'loop', 'every', 'frame', 'huge', 'amount', 'supporting', 'code', 'could', 'potentially', 'ctypes', 'import', 'thats', 'project', 'ive', 'used', 'tool', 'recent']"
Python,"I used Cython in a scientific data processing pipeline where the code had to be comprehensible-ish to my data scientist coworkers.

The bottleneck was a huge runtime/memory overhead when I tried to refactor some components for parsing genomic data. It was a huge mess, but when I tried to replace tuples, dozens of lookup tables and stringly typed everything into well-defined dataclasses the performance was unacceptable.

So I considered native code, but that would have been a huge maintenance burden and made me a single point of failure. So I decided to use Cython in its pure Python mode and separated the parsing logic (and more importantly the data classes) into its own module.

I picked a rather self-contained minor parsing component as a proof of concept first. It was IO-bound and already mostly using native builtins. I still increased runtime performance twofold and memory footprint fivefold while making the calling code much more readable, which was actually my only goal (I would have accepted similar performance characteristics).

I tried to optimize it further because I thought it was still creating Python overhead unnecessarily. I would have loved to return byte strings from a shared memory buffer but unfortunately that’s not how Python‘s byte type works, so I had to accept that Python would still create separate byte objects with copies of the original content for some properties.

Which is to say: Beware of the fundamental compromises a native module will bring. The best use case is something that works completely autonomously and can just return the final result to the Python code, like numpy. Similarly, the most efficient data structures are those that never have to leave your native code. As soon as you have a back and forth between Python and native code you will incur runtime overhead and create Python objects with all their header overhead. Depending on your code (think of a tight loop producing many small objects) that might be a non-starter or perform even worse than pure Python. But to be fair, Cython does have a simple way to keep a fixed-size static list of pre-allocated objects of your structure to reuse them for temporary objects. Doesn’t help when you want to collect them into a list though.

>How was the integration process—setup, debugging, maintenance?

It was expectedly less streamlined than pure Python. The build process became more complicated. Now there is two compile steps that weren’t necessary before. Testing also requires some extra setup to get correct coverage information and suddenly you will have build artifacts all over your code base (for compiled modules) that you want to get rid of for clean builds or debugging. Otherwise you can easily look at a piece of code while the code being executed from the compiled binary is actually completely different (it’s .pyc files but worse). Debugging itself was fine with PyCharm Professional. I actually don’t remember if I stepped into native code though.

Despite tooling support for Cython you can expect some hiccups with linters and IDEs, at least with the pure Python mode, which is less supported (things will be detected as missing even though the Cython module exports them, cimports in particular).

>In hindsight, would you do it the same way again?

For that module, definitely no. I still see it as the only option to make the rest of the code cleaner while keeping the performance up, but on the other hand it will never be fully maintainable by my non-engineer colleagues beyond minor tweaks, so I’m not sure it’s worth it, especially given the more complicated setup and more things that can go wrong with nobody to troubleshoot them but me. I remember setuptools and poetry causing some problems initially.

Some difficulties were certainly my own fault. Cython’s pure Python mode allows a subset of its features to be used even without compiling (they’re just plain Python then, without the speedup). My goal was to achieve full Python compatibility so that the difference between compiling and running as is would be seamless. It made the setup much more complicated though, because now your tooling/scripts have to account for two modes of building/testing/running the code.

Long story short: Think twice before using it and consider it only if you have buy-in. Everyone (or more than one person) working on the codebase should be willing to dig into Cython and step through its internals if necessary, because there aren’t that many (up-to-date) online resources to rely on.",2025-04-25T15:34:32,"['used', 'cython', 'scientific', 'data', 'processing', 'pipeline', 'code', 'comprehensibleish', 'data', 'scientist', 'coworkers', 'bottleneck', 'huge', 'runtimememory', 'overhead', 'tried', 'refactor', 'component', 'parsing', 'genomic', 'data', 'huge', 'mess', 'tried', 'replace', 'tuples', 'dozen', 'lookup', 'table', 'stringly', 'typed', 'everything', 'welldefined', 'dataclasses', 'performance', 'unacceptable', 'considered', 'native', 'code', 'would', 'huge', 'maintenance', 'burden', 'made', 'single', 'point', 'failure', 'decided', 'use', 'cython', 'pure', 'python', 'mode', 'separated', 'parsing', 'logic', 'importantly', 'data', 'class', 'module', 'picked', 'rather', 'selfcontained', 'minor', 'parsing', 'component', 'proof', 'concept', 'first', 'iobound', 'already', 'mostly', 'using', 'native', 'builtins', 'still', 'increased', 'runtime', 'performance', 'twofold', 'memory', 'footprint', 'fivefold', 'making', 'calling', 'code', 'much', 'readable', 'actually', 'goal', 'would', 'accepted', 'similar', 'performance', 'characteristic', 'tried', 'optimize', 'thought', 'still', 'creating', 'python', 'overhead', 'unnecessarily', 'would', 'loved', 'return', 'byte', 'string', 'shared', 'memory', 'buffer', 'unfortunately', 'that’s', 'python‘s', 'byte', 'type', 'work', 'accept', 'python', 'would', 'still', 'create', 'separate', 'byte', 'object', 'copy', 'original', 'content', 'property', 'say', 'beware', 'fundamental', 'compromise', 'native', 'module', 'bring', 'best', 'use', 'case', 'something', 'work', 'completely', 'autonomously', 'return', 'final', 'result', 'python', 'code', 'like', 'numpy', 'similarly', 'efficient', 'data', 'structure', 'never', 'leave', 'native', 'code', 'soon', 'back', 'forth', 'python', 'native', 'code', 'incur', 'runtime', 'overhead', 'create', 'python', 'object', 'header', 'overhead', 'depending', 'code', 'think', 'tight', 'loop', 'producing', 'many', 'small', 'object', 'might', 'nonstarter', 'perform', 'even', 'worse', 'pure', 'python', 'fair', 'cython', 'simple', 'way', 'keep', 'fixedsize', 'static', 'list', 'preallocated', 'object', 'structure', 'reuse', 'temporary', 'object', 'doesn’t', 'help', 'want', 'collect', 'list', 'though', 'integration', 'process—setup', 'debugging', 'maintenance', 'expectedly', 'less', 'streamlined', 'pure', 'python', 'build', 'process', 'became', 'complicated', 'two', 'compile', 'step', 'weren’t', 'necessary', 'testing', 'also', 'requires', 'extra', 'setup', 'get', 'correct', 'coverage', 'information', 'suddenly', 'build', 'artifact', 'code', 'base', 'compiled', 'module', 'want', 'get', 'rid', 'clean', 'build', 'debugging', 'otherwise', 'easily', 'look', 'piece', 'code', 'code', 'executed', 'compiled', 'binary', 'actually', 'completely', 'different', 'it’s', 'pyc', 'file', 'worse', 'debugging', 'fine', 'pycharm', 'professional', 'actually', 'don’t', 'remember', 'stepped', 'native', 'code', 'though', 'despite', 'tooling', 'support', 'cython', 'expect', 'hiccup', 'linters', 'ides', 'least', 'pure', 'python', 'mode', 'less', 'supported', 'thing', 'detected', 'missing', 'even', 'though', 'cython', 'module', 'export', 'cimports', 'particular', 'hindsight', 'would', 'way', 'module', 'definitely', 'still', 'see', 'option', 'make', 'rest', 'code', 'cleaner', 'keeping', 'performance', 'hand', 'never', 'fully', 'maintainable', 'nonengineer', 'colleague', 'beyond', 'minor', 'tweak', 'i’m', 'sure', 'it’s', 'worth', 'especially', 'given', 'complicated', 'setup', 'thing', 'go', 'wrong', 'nobody', 'troubleshoot', 'remember', 'setuptools', 'poetry', 'causing', 'problem', 'initially', 'difficulty', 'certainly', 'fault', 'cython’s', 'pure', 'python', 'mode', 'allows', 'subset', 'feature', 'used', 'even', 'without', 'compiling', 'they’re', 'plain', 'python', 'without', 'speedup', 'goal', 'achieve', 'full', 'python', 'compatibility', 'difference', 'compiling', 'running', 'would', 'seamless', 'made', 'setup', 'much', 'complicated', 'though', 'toolingscripts', 'account', 'two', 'mode', 'buildingtestingrunning', 'code', 'long', 'story', 'short', 'think', 'twice', 'using', 'consider', 'buyin', 'everyone', 'one', 'person', 'working', 'codebase', 'willing', 'dig', 'cython', 'step', 'internals', 'necessary', 'aren’t', 'many', 'uptodate', 'online', 'resource', 'rely']"
Python,"My specific use case is in scientific computing. I'm a PhD student doing research in algorithms, namely particle filters (those being the most memory-intensive). I run many repetitions of simulations.

On the Python side I've used both Numba and MyPyC. Cython is a complete non-starter for me. If I'm working in Python, I want to be working in Python, and not in some pseudo-Python language. My usual performance benchmark is a naive recursive Fibonacci sequence, just something dumb and basic and that I know I can force to take a human-discernible amount of time. Numba with array computation, and MyPyC with type annotation achieves performance on-par with native compiled C/C++/Rust.

The issue I had with MyPyC is that it *only* works on native Python code. It's a really great idea and I think if they can get it to the point where it works with extension libraries also written in Python (even better if it can also work with libraries written in C like NumPy) it will make Python pretty damn unbeatable as you'll be able to test in interpreted mode and deploy in compiled. Until then, the strength of Python is the ecosystem, not the standard library, so that option was out.

Numba on the other hand is pretty great. It works well with NumPy and seeing as most scientific/computation Python libraries are based on NumPy, has a good ecosystem support. I find that Numba is best used for when everything else is in Python, save for this one loop/function call that is bottle-necking your code, and that code can be re-written using NumPy arrays. Better yet if it can be vectorized. Even jitting a dumb for loop of array calculations should get you a performance bump.

The problems with Numba are two fold: first it throws weird bugs and is really difficult to debug in my opinion; and second, for some reason jitted modules can't talk to each other. For instance: if I have module foo with jitted function bar, and I want to bar from a jitted function in another module it doesn't work. At least, I haven't been able to get it working. This kind of echos the problem of MyPyC. The strength of Python is the ecosystem, and Numba seemingly forced me into either adopting a third party library wholesale, and shoe-horning my functionality in somehow with whatever bottlenecks that produced, or alternatively building the entire library with my added functionality myself.

The specific bottleneck for me was looping over a set of calculations that I didn't want to vectorize. I had some reused functionality that was consistent across three different use cases that I didn't want to have to build and test for each (Particle filter, UKF/EKF) which vectorizing for the particle filter would have forced me to do. As such the solution was to move to writing an extension module so that I could take advantage of compiled speed even if it meant writing naive un-optimized libraries as compilation (and compiler optimization) would still be a significant boost to native Python.

Frankly, I've found that using pybind11/nanobind for C++ or maturin and pyo3 for Rust are basically the same. The style is the same. The structure is the same. I find that matruin and pyo3 is a more streamlined experience and that Rust, in general, is just a much better experience than C++, but use whichever. Personally I prefer Rust. Memory safety is great and all, but the tooling is absolutely superb and I find that I like Rust's syntax more than C++. Rust feels like Python and C++ had a baby and unlearned all the pre-C++11 problems. Either way, this is the Python sub so it doesn't matter too much which compiled language you use. You'll still see a benefit and Python's garbage collector should handle the memory safety. If you haven't taken a look at it check out The Scientific Python Development Guide to [Packaging Compiled Projects](https://learn.scientific-python.org/development/guides/packaging-compiled/).

That said... committing to re-writing the bottle-necked backend in a compiled language made me realize that I really should just be doing the entire backend algorithm in Rust. So while not necessarily the question you were asking, what I've found is that if I'm getting to the point where I *really need* compiled performance, in all likelihood  that means it is time to learn how to use a compiled language, even if it is just to write simple naive implementations, and use Python instead for your data pre- and post-processing. Bindings are pretty solid, and I plan on writing some for my code, but there is still some performance overhead with the interpreter, GIL (multiprocessing only gets you so far), and Python's garbage collection.",2025-04-25T16:03:38,"['specific', 'use', 'case', 'scientific', 'computing', 'im', 'phd', 'student', 'research', 'algorithm', 'namely', 'particle', 'filter', 'memoryintensive', 'run', 'many', 'repetition', 'simulation', 'python', 'side', 'ive', 'used', 'numba', 'mypyc', 'cython', 'complete', 'nonstarter', 'im', 'working', 'python', 'want', 'working', 'python', 'pseudopython', 'language', 'usual', 'performance', 'benchmark', 'naive', 'recursive', 'fibonacci', 'sequence', 'something', 'dumb', 'basic', 'know', 'force', 'take', 'humandiscernible', 'amount', 'time', 'numba', 'array', 'computation', 'mypyc', 'type', 'annotation', 'achieves', 'performance', 'onpar', 'native', 'compiled', 'ccrust', 'issue', 'mypyc', 'work', 'native', 'python', 'code', 'really', 'great', 'idea', 'think', 'get', 'point', 'work', 'extension', 'library', 'also', 'written', 'python', 'even', 'better', 'also', 'work', 'library', 'written', 'c', 'like', 'numpy', 'make', 'python', 'pretty', 'damn', 'unbeatable', 'youll', 'able', 'test', 'interpreted', 'mode', 'deploy', 'compiled', 'strength', 'python', 'ecosystem', 'standard', 'library', 'option', 'numba', 'hand', 'pretty', 'great', 'work', 'well', 'numpy', 'seeing', 'scientificcomputation', 'python', 'library', 'based', 'numpy', 'good', 'ecosystem', 'support', 'find', 'numba', 'best', 'used', 'everything', 'else', 'python', 'save', 'one', 'loopfunction', 'call', 'bottlenecking', 'code', 'code', 'rewritten', 'using', 'numpy', 'array', 'better', 'yet', 'vectorized', 'even', 'jitting', 'dumb', 'loop', 'array', 'calculation', 'get', 'performance', 'bump', 'problem', 'numba', 'two', 'fold', 'first', 'throw', 'weird', 'bug', 'really', 'difficult', 'debug', 'opinion', 'second', 'reason', 'jitted', 'module', 'cant', 'talk', 'instance', 'module', 'foo', 'jitted', 'function', 'bar', 'want', 'bar', 'jitted', 'function', 'another', 'module', 'doesnt', 'work', 'least', 'havent', 'able', 'get', 'working', 'kind', 'echo', 'problem', 'mypyc', 'strength', 'python', 'ecosystem', 'numba', 'seemingly', 'forced', 'either', 'adopting', 'third', 'party', 'library', 'wholesale', 'shoehorning', 'functionality', 'somehow', 'whatever', 'bottleneck', 'produced', 'alternatively', 'building', 'entire', 'library', 'added', 'functionality', 'specific', 'bottleneck', 'looping', 'set', 'calculation', 'didnt', 'want', 'vectorize', 'reused', 'functionality', 'consistent', 'across', 'three', 'different', 'use', 'case', 'didnt', 'want', 'build', 'test', 'particle', 'filter', 'ukfekf', 'vectorizing', 'particle', 'filter', 'would', 'forced', 'solution', 'move', 'writing', 'extension', 'module', 'could', 'take', 'advantage', 'compiled', 'speed', 'even', 'meant', 'writing', 'naive', 'unoptimized', 'library', 'compilation', 'compiler', 'optimization', 'would', 'still', 'significant', 'boost', 'native', 'python', 'frankly', 'ive', 'found', 'using', 'pybind11nanobind', 'c', 'maturin', 'pyo3', 'rust', 'basically', 'style', 'structure', 'find', 'matruin', 'pyo3', 'streamlined', 'experience', 'rust', 'general', 'much', 'better', 'experience', 'c', 'use', 'whichever', 'personally', 'prefer', 'rust', 'memory', 'safety', 'great', 'tooling', 'absolutely', 'superb', 'find', 'like', 'rust', 'syntax', 'c', 'rust', 'feel', 'like', 'python', 'c', 'baby', 'unlearned', 'prec11', 'problem', 'either', 'way', 'python', 'sub', 'doesnt', 'matter', 'much', 'compiled', 'language', 'use', 'youll', 'still', 'see', 'benefit', 'python', 'garbage', 'collector', 'handle', 'memory', 'safety', 'havent', 'taken', 'look', 'check', 'scientific', 'python', 'development', 'guide', 'packaging', 'compiled', 'project', 'said', 'committing', 'rewriting', 'bottlenecked', 'backend', 'compiled', 'language', 'made', 'realize', 'really', 'entire', 'backend', 'algorithm', 'rust', 'necessarily', 'question', 'asking', 'ive', 'found', 'im', 'getting', 'point', 'really', 'need', 'compiled', 'performance', 'likelihood', 'mean', 'time', 'learn', 'use', 'compiled', 'language', 'even', 'write', 'simple', 'naive', 'implementation', 'use', 'python', 'instead', 'data', 'pre', 'postprocessing', 'binding', 'pretty', 'solid', 'plan', 'writing', 'code', 'still', 'performance', 'overhead', 'interpreter', 'gil', 'multiprocessing', 'get', 'far', 'python', 'garbage', 'collection']"
Python,"I sped up PyBoy with Cython and have used it several other places with good success. The speed up is in the x200-300 compared to CPython. But you’re probably unlikely to find such a good use case.
For debugging I use LLDB as well as CPython and PyPy. It’s usually easiest if the error is also present in the interpreter. But otherwise you know it’s a type issue.

https://github.com/Baekalfen/PyBoy",2025-04-25T17:04:48,"['sped', 'pyboy', 'cython', 'used', 'several', 'place', 'good', 'success', 'speed', 'x200300', 'compared', 'cpython', 'you’re', 'probably', 'unlikely', 'find', 'good', 'use', 'case', 'debugging', 'use', 'lldb', 'well', 'cpython', 'pypy', 'it’s', 'usually', 'easiest', 'error', 'also', 'present', 'interpreter', 'otherwise', 'know', 'it’s', 'type', 'issue']"
Python,"I’m into reverse engineering and built a small library for code injection, virtual memory allocation, and simple memory management in target processes. Performance was important, especially for multithreaded AOB scans without the GIL.

Python wasn’t ideal, dynamic typing and CPython’s speed are both issues, especially when scanning a process memory. So I wrote the core in C and Cython.

Setup was a bit annoying and packaging was even more painful (mainly Python’s fault). But prange for multithreading was a nice, and I liked how Cython let me keep pure C code separate from hybrid C/Python parts. Much cleaner and faster than using ctypes to wrap, and none of the code used GIL.",2025-04-25T13:18:51,"['i’m', 'reverse', 'engineering', 'built', 'small', 'library', 'code', 'injection', 'virtual', 'memory', 'allocation', 'simple', 'memory', 'management', 'target', 'process', 'performance', 'important', 'especially', 'multithreaded', 'aob', 'scan', 'without', 'gil', 'python', 'wasn’t', 'ideal', 'dynamic', 'typing', 'cpython’s', 'speed', 'issue', 'especially', 'scanning', 'process', 'memory', 'wrote', 'core', 'c', 'cython', 'setup', 'bit', 'annoying', 'packaging', 'even', 'painful', 'mainly', 'python’s', 'fault', 'prange', 'multithreading', 'nice', 'liked', 'cython', 'let', 'keep', 'pure', 'c', 'code', 'separate', 'hybrid', 'cpython', 'part', 'much', 'cleaner', 'faster', 'using', 'ctypes', 'wrap', 'none', 'code', 'used', 'gil']"
Python,"Not me, but a very clever person built sabctools [https://github.com/sabnzbd/sabctools](https://github.com/sabnzbd/sabctools) : ""yEnc decoding and encoding using SIMD routines"" and ""CRC32 calculations""

Speed improvements were 10-100x or so compared to plain C (wihout SIMD). And plain python ... almost unusable.",2025-04-25T14:00:59,"['clever', 'person', 'built', 'sabctools', 'yenc', 'decoding', 'encoding', 'using', 'simd', 'routine', 'crc32', 'calculation', 'speed', 'improvement', '10100x', 'compared', 'plain', 'c', 'wihout', 'simd', 'plain', 'python', 'almost', 'unusable']"
Python,"I made [Tamp](https://github.com/BrianPugh/tamp), low-memory lossless compression library that was originally targetting micropython. So naturally, I prototyped it in vanilla cpython. Once I saw that general compression ratios were good, I then reimplemented it in C so that I could also use it without micropython on any microcontroller. I used Cython to have a fast python-compatible implementation, as well as to unit test the C parts of the code (I'd much rather write unit tests in python rather than C).

In this library, the C/Cython compression is about 6.7x faster, while decompression 535x faster. The compression isn't much faster because the main compression loop, finding the longest substring match in a buffer, is already implemented fairly efficiently in python via `str.index`.

  
Cython has a bit of a learning curve, but their docs are actually quite comprehensive. I distilled my learnings into [my python template](https://github.com/BrianPugh/python-template), which has Cython working with Poetry and CI to build binaries for all python versions and architectures. I would definitely use Cython again for this purpose (creating a pythonic interface to C code). Given that the code within Cython should be minimal/simple/short/self-contained, things like ChatGPT work very well for helping!",2025-04-25T14:36:47,"['made', 'tamp', 'lowmemory', 'lossless', 'compression', 'library', 'originally', 'targetting', 'micropython', 'naturally', 'prototyped', 'vanilla', 'cpython', 'saw', 'general', 'compression', 'ratio', 'good', 'reimplemented', 'c', 'could', 'also', 'use', 'without', 'micropython', 'microcontroller', 'used', 'cython', 'fast', 'pythoncompatible', 'implementation', 'well', 'unit', 'test', 'c', 'part', 'code', 'id', 'much', 'rather', 'write', 'unit', 'test', 'python', 'rather', 'c', 'library', 'ccython', 'compression', '67x', 'faster', 'decompression', '535x', 'faster', 'compression', 'isnt', 'much', 'faster', 'main', 'compression', 'loop', 'finding', 'longest', 'substring', 'match', 'buffer', 'already', 'implemented', 'fairly', 'efficiently', 'python', 'via', 'strindex', 'cython', 'bit', 'learning', 'curve', 'doc', 'actually', 'quite', 'comprehensive', 'distilled', 'learning', 'python', 'template', 'cython', 'working', 'poetry', 'ci', 'build', 'binary', 'python', 'version', 'architecture', 'would', 'definitely', 'use', 'cython', 'purpose', 'creating', 'pythonic', 'interface', 'c', 'code', 'given', 'code', 'within', 'cython', 'minimalsimpleshortselfcontained', 'thing', 'like', 'chatgpt', 'work', 'well', 'helping']"
Python,"My open source Python extensions: [velocem](https://github.com/nickelpro/velocem), [nanoroute](https://nanoroute.dev/)

* Latency in general, everything is faster in native code

* C++ and the CPython API

* Between 30x and 1000x, depending on what metric you measure

* It's normal C++ development for the most part

* Yes, I think most Python should be setting up fast extension-based code to do its job and then getting out of the way.",2025-04-25T21:31:35,"['open', 'source', 'python', 'extension', 'velocem', 'nanoroute', 'latency', 'general', 'everything', 'faster', 'native', 'code', 'c', 'cpython', 'api', '30x', '1000x', 'depending', 'metric', 'measure', 'normal', 'c', 'development', 'part', 'yes', 'think', 'python', 'setting', 'fast', 'extensionbased', 'code', 'job', 'getting', 'way']"
Python,"I’d say for the majority of my experience has depended on how long I plan on updating the code. For small things that I am working on primarily in Python when I have a couple of functions I just want to run faster, a JIT like Numba or JAX is nice and simple. Sometimes the bottleneck is efficient multithreading and memory management, and in those cases, I personally use Rust. 

> Specific performance issue

I needed code that could evaluate a complex function (or many functions) over a large set of datapoints many times, preferably in parallel. JITs didn’t cut it because the core issue was also that Python would load everything into memory and quickly max out my RAM, while still being much slower than C programs I was competing with.

> What tool and why

I chose Rust for a couple of reasons. First, I like how the crate system works, I don’t have to depend on the user to know how to install a bunch of different dependencies via various makefiles, cmake, ninja, meson, etc etc. I also like the memory management, it’s not too manual, but also gives me enough control to be efficient. I don’t mind programming in C/C++, but I certainly don’t enjoy it as much.

> Speedup

It’s hard to say because I never had the full product working with Python alone, but it has definitely been significantly faster than anything I wrote in Python. Again, I don’t have hard numbers, but it’s orders of magnitude.

> Integration process

Debugging Rust code is easy (skill issue if you can’t figure out what the compiler wants after it explicitly tells you what’s wrong). PyO3 was a bit tricky, since you have to learn how Python actually manages memory, something Python devs can usually ignore. Maturin is not entirely straightforward with how to organize a Python extension or how to actually write the Python API, but I just looked at big projects like polars for inspiration.

> Hindsight

Yes, in hindsight I would start with Rust rather than fumbling around with JITs. They’re nice if you don’t know how to use a lower-level language, but in the end they get into edge cases if you use them enough. Complex numbers aren’t really supported in JAX for a number of reasons, and you often have to hand roll linear algebra or complex computations that aren’t JITted, like anything in scipy or scikit-learn.


I think the major tradeoff for me was that I had to learn Rust. I don’t regret this, I think it’s made me a better programmer, but it took time and a lot of work to get the Rust code working the way I wanted. I’m so used to OOP it was tricky to get out of that mindset.",2025-04-25T15:33:58,"['i’d', 'say', 'majority', 'experience', 'depended', 'long', 'plan', 'updating', 'code', 'small', 'thing', 'working', 'primarily', 'python', 'couple', 'function', 'want', 'run', 'faster', 'jit', 'like', 'numba', 'jax', 'nice', 'simple', 'sometimes', 'bottleneck', 'efficient', 'multithreading', 'memory', 'management', 'case', 'personally', 'use', 'rust', 'specific', 'performance', 'issue', 'needed', 'code', 'could', 'evaluate', 'complex', 'function', 'many', 'function', 'large', 'set', 'datapoints', 'many', 'time', 'preferably', 'parallel', 'jits', 'didn’t', 'cut', 'core', 'issue', 'also', 'python', 'would', 'load', 'everything', 'memory', 'quickly', 'max', 'ram', 'still', 'much', 'slower', 'c', 'program', 'competing', 'tool', 'chose', 'rust', 'couple', 'reason', 'first', 'like', 'crate', 'system', 'work', 'don’t', 'depend', 'user', 'know', 'install', 'bunch', 'different', 'dependency', 'via', 'various', 'makefiles', 'cmake', 'ninja', 'meson', 'etc', 'etc', 'also', 'like', 'memory', 'management', 'it’s', 'manual', 'also', 'give', 'enough', 'control', 'efficient', 'don’t', 'mind', 'programming', 'cc', 'certainly', 'don’t', 'enjoy', 'much', 'speedup', 'it’s', 'hard', 'say', 'never', 'full', 'product', 'working', 'python', 'alone', 'definitely', 'significantly', 'faster', 'anything', 'wrote', 'python', 'don’t', 'hard', 'number', 'it’s', 'order', 'magnitude', 'integration', 'process', 'debugging', 'rust', 'code', 'easy', 'skill', 'issue', 'can’t', 'figure', 'compiler', 'want', 'explicitly', 'tell', 'what’s', 'wrong', 'pyo3', 'bit', 'tricky', 'since', 'learn', 'python', 'actually', 'manages', 'memory', 'something', 'python', 'devs', 'usually', 'ignore', 'maturin', 'entirely', 'straightforward', 'organize', 'python', 'extension', 'actually', 'write', 'python', 'api', 'looked', 'big', 'project', 'like', 'polars', 'inspiration', 'hindsight', 'yes', 'hindsight', 'would', 'start', 'rust', 'rather', 'fumbling', 'around', 'jits', 'they’re', 'nice', 'don’t', 'know', 'use', 'lowerlevel', 'language', 'end', 'get', 'edge', 'case', 'use', 'enough', 'complex', 'number', 'aren’t', 'really', 'supported', 'jax', 'number', 'reason', 'often', 'hand', 'roll', 'linear', 'algebra', 'complex', 'computation', 'aren’t', 'jitted', 'like', 'anything', 'scipy', 'scikitlearn', 'think', 'major', 'tradeoff', 'learn', 'rust', 'don’t', 'regret', 'think', 'it’s', 'made', 'better', 'programmer', 'took', 'time', 'lot', 'work', 'get', 'rust', 'code', 'working', 'way', 'wanted', 'i’m', 'used', 'oop', 'tricky', 'get', 'mindset']"
Python,"I've used cython for writing device interface drivers.  It's a lot faster for hitting I/O and memory and running tight loops.

The specific bottleneck/limitation was DMA and in some cases bit-banging pins.  It's so easy to just do it like you would in C.  Then you write some cython-intermediate code and it's great to use their HTML output thing to show you the generated code and where it could be better.

Cython got a lot easier to use with cython 3 and type hinting.",2025-04-25T21:32:31,"['ive', 'used', 'cython', 'writing', 'device', 'interface', 'driver', 'lot', 'faster', 'hitting', 'io', 'memory', 'running', 'tight', 'loop', 'specific', 'bottlenecklimitation', 'dma', 'case', 'bitbanging', 'pin', 'easy', 'like', 'would', 'c', 'write', 'cythonintermediate', 'code', 'great', 'use', 'html', 'output', 'thing', 'show', 'generated', 'code', 'could', 'better', 'cython', 'got', 'lot', 'easier', 'use', 'cython', '3', 'type', 'hinting']"
Python,"I wrote a computational electromagnetics code with a C backend and a Python wrapper. The C code was about 1000x faster than the python code and about 10-50x faster than Numba. 

I love writing C code (because it’s so simple and easy for me to understand - my programs are not that complex) but in the same vein I make so many mistakes in memory management that I’ve started to write new code in Rust and noticed a huge improvement in code quality and productivity. ",2025-04-26T02:56:50,"['wrote', 'computational', 'electromagnetics', 'code', 'c', 'backend', 'python', 'wrapper', 'c', 'code', '1000x', 'faster', 'python', 'code', '1050x', 'faster', 'numba', 'love', 'writing', 'c', 'code', 'it’s', 'simple', 'easy', 'understand', 'program', 'complex', 'vein', 'make', 'many', 'mistake', 'memory', 'management', 'i’ve', 'started', 'write', 'new', 'code', 'rust', 'noticed', 'huge', 'improvement', 'code', 'quality', 'productivity']"
Python,"Here is a presentation from my talk where I showed the performance improvement when porting several tasks from `python`\+`numpy`\+`numba`\+etc to `Rust`(`PyO3`): [https://drive.google.com/file/d/1mv4DXHHwth319F23TQKg1-8L5qoKRQ70/view?usp=sharing](https://drive.google.com/file/d/1mv4DXHHwth319F23TQKg1-8L5qoKRQ70/view?usp=sharing) It's in Russian, but the plots are quite obvious. I got a 3-5x speedup and a dramatic reduction in memory consumption.

I write a lot of simple math for data processing for ML. In my work I've moved away from `Cython`, to extensions on `Rust`. I still use `numba` wherever possible because of its simplicity.",2025-04-26T10:22:07,"['presentation', 'talk', 'showed', 'performance', 'improvement', 'porting', 'several', 'task', 'pythonnumpynumbaetc', 'rustpyo3', 'russian', 'plot', 'quite', 'obvious', 'got', '35x', 'speedup', 'dramatic', 'reduction', 'memory', 'consumption', 'write', 'lot', 'simple', 'math', 'data', 'processing', 'ml', 'work', 'ive', 'moved', 'away', 'cython', 'extension', 'rust', 'still', 'use', 'numba', 'wherever', 'possible', 'simplicity']"
Python,I hated Cython but tried it recently on a native hashing function for a project I am working on. Wow! Type extensions with pure python mode made it trivial. Like a 100x speed up. Pretty incredible. Cython 3 is a game changer.,2025-04-27T03:25:16,"['hated', 'cython', 'tried', 'recently', 'native', 'hashing', 'function', 'project', 'working', 'wow', 'type', 'extension', 'pure', 'python', 'mode', 'made', 'trivial', 'like', '100x', 'speed', 'pretty', 'incredible', 'cython', '3', 'game', 'changer']"
Python,I wrote some small helper functions for a project I was doing that involved large graphs and groupings to do faster set operations and DFS. It was really a night and day difference that I think warrants people who are into Python to look at Rust.,2025-04-25T14:51:22,"['wrote', 'small', 'helper', 'function', 'project', 'involved', 'large', 'graph', 'grouping', 'faster', 'set', 'operation', 'dfs', 'really', 'night', 'day', 'difference', 'think', 'warrant', 'people', 'python', 'look', 'rust']"
Python,"I've wrote a C extension for one of my python projects that reads from an SPI peripheral device and processes the results. My project needed to do this as fast as possible, and the C extension sped things up tremendously. Then, I passed the processed results back to Python for higher level integration into the rest of the application. 

It was a bit of a learning curve because it's been years since I touched C, and I was never really great with it. The Python specifics dealing with reference counts was a bit tricky too. But overall it wasn't that bad. I had a couple memory leaks in my C extension that I had to learn how to debug, but once I found those it was rock solid.

Setting up a build pipeline and packaging strategy was equally as difficult, but not too bad either.",2025-04-25T19:10:20,"['ive', 'wrote', 'c', 'extension', 'one', 'python', 'project', 'read', 'spi', 'peripheral', 'device', 'process', 'result', 'project', 'needed', 'fast', 'possible', 'c', 'extension', 'sped', 'thing', 'tremendously', 'passed', 'processed', 'result', 'back', 'python', 'higher', 'level', 'integration', 'rest', 'application', 'bit', 'learning', 'curve', 'year', 'since', 'touched', 'c', 'never', 'really', 'great', 'python', 'specific', 'dealing', 'reference', 'count', 'bit', 'tricky', 'overall', 'wasnt', 'bad', 'couple', 'memory', 'leak', 'c', 'extension', 'learn', 'debug', 'found', 'rock', 'solid', 'setting', 'build', 'pipeline', 'packaging', 'strategy', 'equally', 'difficult', 'bad', 'either']"
Python,"I look at it this way, python isn’t always the right choice!    

However when using Python I generally use somebody else’s native solution.",2025-04-25T19:32:43,"['look', 'way', 'python', 'isn’t', 'always', 'right', 'choice', 'however', 'using', 'python', 'generally', 'use', 'somebody', 'else’s', 'native', 'solution']"
Python,"I was doing some physics simulations that calculate the total field from a function that operates on two input arrays, and produces an output array of a field.


The two arrays were m x 3 and n x 3 in size, and the function had about fifty operations that were performed.  It was not exactly matrix multiplication but in intermediate steps an m x n x 6 array could be created depending on how it was implemented.



The initial naive method was just to implement this on scalars and input Python lists.  List comprehension would then be used to act on the arrays, and the final result reduced to an n x 3 array.  This was very slow, and could use more than 64 gigs of memory for large arrays, but for simple cases you could wait it out.


The first step up in speed was to move to numpy array operations which was faster and more memory efficient than python lists.


At the same time the calculation was changed such that the largest array was n x 3 in the calculation.  This reduced the memory requirements, removed access to the individual contributions of the members, but that was never needed in practice.


This was used for a while, but eventually optimization searches required thousands of different m x 3 input arrays to be calculated at a time. This was taking hours and overnight calculations were common.


The next speed up was to add numba JIT compilation.  This required some re-writing of the function to remove unsupported numpy operations but was a 30-40% reduction in calculation time and reduced the memory requirements so larger arrays could be used, and fewer approximations or interpolations were required between data points.


The next speed up attempt was to write a C function to replace the Python function using ctypes.  This was about a factor of twenty faster on individual rows when tested in pure C code, but converting from Python data types, to C data types and back to Python when calling the function in Python was slower than the numba code by a factor of 2-5 IIRC.  Rather than move all of the data storage to C, we just stuck with the numba code for months.


A 20% speed up was found by identifying common terms between different stages of the calculations in the function,  such as if A, B and C are calculated individually and then then several lines later E = D(A/C)/(B/C), just calculate E=DA/B. 


This removed the physical interpretation of some intermediate steps, but those didn't need to be referenced after the initial validation of the function. This was used for a few more months.




Using the Blaze C++ library for array calculations was examined, and it was faster than plain C code as it could parallelize the calculations in the background, but some functions from Python libraries could not easily be ported to C++,  and passing data back and forth between Python and C++ seemed more complicated than was worth the while to program at the time.


Eventually the optimization efforts grew complicated enough that it was desired to use a genetic algorithm.  This required many more repetitions of the calculation to get to a useful final result , so the main function was converted into a C extension for numpy.  This allowed compiled C code to do the work, and removed the need to convert data types.   This was several times faster than numba.


CUDA was beginning to be examined as a solution to running more calculations in parallel speed up the operations, but as no one in the group knew how to use CUDA it was never implemented before a sufficient result was found using the numpy extension over a few weeks of calculation.",2025-04-26T01:25:54,"['physic', 'simulation', 'calculate', 'total', 'field', 'function', 'operates', 'two', 'input', 'array', 'produce', 'output', 'array', 'field', 'two', 'array', 'x', '3', 'n', 'x', '3', 'size', 'function', 'fifty', 'operation', 'performed', 'exactly', 'matrix', 'multiplication', 'intermediate', 'step', 'x', 'n', 'x', '6', 'array', 'could', 'created', 'depending', 'implemented', 'initial', 'naive', 'method', 'implement', 'scalar', 'input', 'python', 'list', 'list', 'comprehension', 'would', 'used', 'act', 'array', 'final', 'result', 'reduced', 'n', 'x', '3', 'array', 'slow', 'could', 'use', '64', 'gig', 'memory', 'large', 'array', 'simple', 'case', 'could', 'wait', 'first', 'step', 'speed', 'move', 'numpy', 'array', 'operation', 'faster', 'memory', 'efficient', 'python', 'list', 'time', 'calculation', 'changed', 'largest', 'array', 'n', 'x', '3', 'calculation', 'reduced', 'memory', 'requirement', 'removed', 'access', 'individual', 'contribution', 'member', 'never', 'needed', 'practice', 'used', 'eventually', 'optimization', 'search', 'required', 'thousand', 'different', 'x', '3', 'input', 'array', 'calculated', 'time', 'taking', 'hour', 'overnight', 'calculation', 'common', 'next', 'speed', 'add', 'numba', 'jit', 'compilation', 'required', 'rewriting', 'function', 'remove', 'unsupported', 'numpy', 'operation', '3040', 'reduction', 'calculation', 'time', 'reduced', 'memory', 'requirement', 'larger', 'array', 'could', 'used', 'fewer', 'approximation', 'interpolation', 'required', 'data', 'point', 'next', 'speed', 'attempt', 'write', 'c', 'function', 'replace', 'python', 'function', 'using', 'ctypes', 'factor', 'twenty', 'faster', 'individual', 'row', 'tested', 'pure', 'c', 'code', 'converting', 'python', 'data', 'type', 'c', 'data', 'type', 'back', 'python', 'calling', 'function', 'python', 'slower', 'numba', 'code', 'factor', '25', 'iirc', 'rather', 'move', 'data', 'storage', 'c', 'stuck', 'numba', 'code', 'month', '20', 'speed', 'found', 'identifying', 'common', 'term', 'different', 'stage', 'calculation', 'function', 'b', 'c', 'calculated', 'individually', 'several', 'line', 'later', 'e', 'dacbc', 'calculate', 'edab', 'removed', 'physical', 'interpretation', 'intermediate', 'step', 'didnt', 'need', 'referenced', 'initial', 'validation', 'function', 'used', 'month', 'using', 'blaze', 'c', 'library', 'array', 'calculation', 'examined', 'faster', 'plain', 'c', 'code', 'could', 'parallelize', 'calculation', 'background', 'function', 'python', 'library', 'could', 'easily', 'ported', 'c', 'passing', 'data', 'back', 'forth', 'python', 'c', 'seemed', 'complicated', 'worth', 'program', 'time', 'eventually', 'optimization', 'effort', 'grew', 'complicated', 'enough', 'desired', 'use', 'genetic', 'algorithm', 'required', 'many', 'repetition', 'calculation', 'get', 'useful', 'final', 'result', 'main', 'function', 'converted', 'c', 'extension', 'numpy', 'allowed', 'compiled', 'c', 'code', 'work', 'removed', 'need', 'convert', 'data', 'type', 'several', 'time', 'faster', 'numba', 'cuda', 'beginning', 'examined', 'solution', 'running', 'calculation', 'parallel', 'speed', 'operation', 'one', 'group', 'knew', 'use', 'cuda', 'never', 'implemented', 'sufficient', 'result', 'found', 'using', 'numpy', 'extension', 'week', 'calculation']"
Python,"I have tried all before. After balancing between simplicity and speed, I almost always just use numba. Pure C or Rust implementations are faster, but not enough to justify the code complexity. I know how to handle them well, but my colleagues not always, and so I would either have to write really detailed README (which even then often gets neglected), or they won't be willing to build on top of that codebase. Cython gives similar performance gain, but is a lot more complex.",2025-04-26T04:05:37,"['tried', 'balancing', 'simplicity', 'speed', 'almost', 'always', 'use', 'numba', 'pure', 'c', 'rust', 'implementation', 'faster', 'enough', 'justify', 'code', 'complexity', 'know', 'handle', 'well', 'colleague', 'always', 'would', 'either', 'write', 'really', 'detailed', 'readme', 'even', 'often', 'get', 'neglected', 'wont', 'willing', 'build', 'top', 'codebase', 'cython', 'give', 'similar', 'performance', 'gain', 'lot', 'complex']"
Python,"I've used Cython for improving performance in code that profiling shows is used heavily in hot loops. My experience is that you get (or at least got at the time - this was a while ago and there have been improvements to CPython's interpreter performance since then) about a 30% speed-up from just compiling the code without changing it, and maybe about a 5× speed-up if you were able to replace refcounted types with native types and structs, and eliminate ""yellow lines"" from the generated code.


Cython has the advantage that it looks like Python, so if you've got a significant number of developers on the team who don't know anything else, there's a better chance they'll be able to work with it, but you're more likely to end up leaving some performance improvement opportunities on the table.",2025-04-26T10:05:36,"['ive', 'used', 'cython', 'improving', 'performance', 'code', 'profiling', 'show', 'used', 'heavily', 'hot', 'loop', 'experience', 'get', 'least', 'got', 'time', 'ago', 'improvement', 'cpythons', 'interpreter', 'performance', 'since', '30', 'speedup', 'compiling', 'code', 'without', 'changing', 'maybe', '5×', 'speedup', 'able', 'replace', 'refcounted', 'type', 'native', 'type', 'structs', 'eliminate', 'yellow', 'line', 'generated', 'code', 'cython', 'advantage', 'look', 'like', 'python', 'youve', 'got', 'significant', 'number', 'developer', 'team', 'dont', 'know', 'anything', 'else', 'there', 'better', 'chance', 'theyll', 'able', 'work', 'youre', 'likely', 'end', 'leaving', 'performance', 'improvement', 'opportunity', 'table']"
Python,"I needed a function to find a line-plane intersection, really just `dp = p2-p; out[:] = p + dp/(dp@wu) * ((P0-p)@wu)` where p,p2 are line points and P0,wu are point and normal unit vector of the plane. Processing in batches was impossible because data arrives in real-time. The main criteria were fast call time from within plain Python code (i.e. no interface friction) and fast import times.

The code eventually boiled down to a function with three numpy arrays as inputs, where the first array merged P0,wu,out together (the number of inputs has quite an impact on interfacing). Time per one call of this function, where the caller lives in plain Python, as well as import times:

* Plain Python + numpy ops: 5000 ns
* Plain Python + no numpy ops (using numpy arrays, but manually indexing): 1800 ns
* Cython: 420 ns (500 µs import)
* Numba JIT: 250 ns (500 ms import for Numba itself, plus 2 ms for every single Numba function, even when cached, which is horrible)
* Numba AOT: 170 ns (400 µs import)
* C with ctypes: 150 ns (300 µs import assuming ctypes is loaded). Requires fetching array pointers beforehand which takes over 1 µs per pointer; and not defining argtypes. I.e. if fetching fresh pointers each time, the time is 3150 ns.
* C with cffi: 110 ns (2 ms import). Requires 10 µs per pointer fetch. But cffi has so many options that there's probably a better setting out there, so take these results with a grain of salt.
* Rust with pyo3: 52.5 ns (500 µs import)
* C API: 40 ns (400 µs import)
* No interfacing (just the intersection): 3 ns. This is tested by writing an outer function in the same setup which loops over a billion samples (slightly modifying point p on the line each time and tracking output). Whether Cython or Numba or C or Rust, the time is pretty much the same because they all do the same thing. Only the interface differs.

Numba does have some dead ends such as jitclass which sounds like a good idea until you realize that it cannot cache at all and a simple class with 10 attributes and one method takes 4 seconds to compile every time (the near-undocumented StructRefs could fix this though I haven't checked how they interact with AOT).

All of this considers just a function that receives three numpy arrays. Classes/structs are quite a different matter, and sadly Numba isn't quite as good with them.",2025-04-26T14:03:54,"['needed', 'function', 'find', 'lineplane', 'intersection', 'really', 'dp', 'p2p', 'p', 'dpdpwu', 'p0pwu', 'pp2', 'line', 'point', 'p0wu', 'point', 'normal', 'unit', 'vector', 'plane', 'processing', 'batch', 'impossible', 'data', 'arrives', 'realtime', 'main', 'criterion', 'fast', 'call', 'time', 'within', 'plain', 'python', 'code', 'ie', 'interface', 'friction', 'fast', 'import', 'time', 'code', 'eventually', 'boiled', 'function', 'three', 'numpy', 'array', 'input', 'first', 'array', 'merged', 'p0wuout', 'together', 'number', 'input', 'quite', 'impact', 'interfacing', 'time', 'per', 'one', 'call', 'function', 'caller', 'life', 'plain', 'python', 'well', 'import', 'time', 'plain', 'python', 'numpy', 'ops', '5000', 'n', 'plain', 'python', 'numpy', 'ops', 'using', 'numpy', 'array', 'manually', 'indexing', '1800', 'n', 'cython', '420', 'n', '500', 'µs', 'import', 'numba', 'jit', '250', 'n', '500', 'm', 'import', 'numba', 'plus', '2', 'm', 'every', 'single', 'numba', 'function', 'even', 'cached', 'horrible', 'numba', 'aot', '170', 'n', '400', 'µs', 'import', 'c', 'ctypes', '150', 'n', '300', 'µs', 'import', 'assuming', 'ctypes', 'loaded', 'requires', 'fetching', 'array', 'pointer', 'beforehand', 'take', '1', 'µs', 'per', 'pointer', 'defining', 'argtypes', 'ie', 'fetching', 'fresh', 'pointer', 'time', 'time', '3150', 'n', 'c', 'cffi', '110', 'n', '2', 'm', 'import', 'requires', '10', 'µs', 'per', 'pointer', 'fetch', 'cffi', 'many', 'option', 'there', 'probably', 'better', 'setting', 'take', 'result', 'grain', 'salt', 'rust', 'pyo3', '525', 'n', '500', 'µs', 'import', 'c', 'api', '40', 'n', '400', 'µs', 'import', 'interfacing', 'intersection', '3', 'n', 'tested', 'writing', 'outer', 'function', 'setup', 'loop', 'billion', 'sample', 'slightly', 'modifying', 'point', 'p', 'line', 'time', 'tracking', 'output', 'whether', 'cython', 'numba', 'c', 'rust', 'time', 'pretty', 'much', 'thing', 'interface', 'differs', 'numba', 'dead', 'end', 'jitclass', 'sound', 'like', 'good', 'idea', 'realize', 'cannot', 'cache', 'simple', 'class', '10', 'attribute', 'one', 'method', 'take', '4', 'second', 'compile', 'every', 'time', 'nearundocumented', 'structrefs', 'could', 'fix', 'though', 'havent', 'checked', 'interact', 'aot', 'considers', 'function', 'receives', 'three', 'numpy', 'array', 'classesstructs', 'quite', 'different', 'matter', 'sadly', 'numba', 'isnt', 'quite', 'good']"
Python,"I don't have any metrics in hand, but I strongly suggest Jax. Just in time compilation with GPU parallelization for free -if you want.
Huge plus the auto-differention capabilities of your functions, which means huge difference in optimization, model fitting etc.
The framework is oriented on deep learning, but in reality this is just a set of applications, jax is capable on any type of modeling (+you can mix your models, functions etc with neural networks). I have used it for several applications, from ship route optimization to astrophysics finite volume methods. 
In my PhD I have heavily used Julia, which have similar capabilities. I would say that jax in comparison is ~1.1 slower (again this is not a measured metric). 
(I also recommend Julia by the way if you are interested )",2025-04-25T21:39:34,"['dont', 'metric', 'hand', 'strongly', 'suggest', 'jax', 'time', 'compilation', 'gpu', 'parallelization', 'free', 'want', 'huge', 'plus', 'autodifferention', 'capability', 'function', 'mean', 'huge', 'difference', 'optimization', 'model', 'fitting', 'etc', 'framework', 'oriented', 'deep', 'learning', 'reality', 'set', 'application', 'jax', 'capable', 'type', 'modeling', 'mix', 'model', 'function', 'etc', 'neural', 'network', 'used', 'several', 'application', 'ship', 'route', 'optimization', 'astrophysics', 'finite', 'volume', 'method', 'phd', 'heavily', 'used', 'julia', 'similar', 'capability', 'would', 'say', 'jax', 'comparison', '11', 'slower', 'measured', 'metric', 'also', 'recommend', 'julia', 'way', 'interested']"
Python,"Transpiling python to rust and shipping standalone binaries (simple single file apps) or pyO3 extensions is something I'd recommend.

Also, LLMs have gotten good at some of these cases. For simple cases, have them translate your code. But then, you'll spend some time debugging and fixing issues. 

Recommend a combination of the two approaches (AST rewriting, deterministic transpilers) and LLM based probabilistic ones depending on the use case.",2025-04-26T00:55:03,"['transpiling', 'python', 'rust', 'shipping', 'standalone', 'binary', 'simple', 'single', 'file', 'apps', 'pyo3', 'extension', 'something', 'id', 'recommend', 'also', 'llm', 'gotten', 'good', 'case', 'simple', 'case', 'translate', 'code', 'youll', 'spend', 'time', 'debugging', 'fixing', 'issue', 'recommend', 'combination', 'two', 'approach', 'ast', 'rewriting', 'deterministic', 'transpilers', 'llm', 'based', 'probabilistic', 'one', 'depending', 'use', 'case']"
Python,This is a cool idea. I’m also curious about what the performance impact is.,2025-04-30T22:49:16,"['cool', 'idea', 'i’m', 'also', 'curious', 'performance', 'impact']"
Python,Neat! Does it only work with single statement functions? ,2025-04-30T20:29:09,"['neat', 'work', 'single', 'statement', 'function']"
Python,"Does it make any noticeable performance difference, or not really? 

Yes Python interpreted, etc. etc. I'm just wondering if eliminating small functions in a hot loop is worthwhile.

Additionally, can you explain the `[T]` syntax on this line, `def inline_cls[T](cls: T) -> T:` ?",2025-04-30T22:36:18,"['make', 'noticeable', 'performance', 'difference', 'really', 'yes', 'python', 'interpreted', 'etc', 'etc', 'im', 'wondering', 'eliminating', 'small', 'function', 'hot', 'loop', 'worthwhile', 'additionally', 'explain', 'syntax', 'line', 'def', 'inlineclstcls']"
Python,"Brutal truth, no.

Just knowing a programming language means nothing if you:

(1) Do not know what role/s to pursue (e.g. Backend development) 

(2) Do not know what the industry standard ways of doing things is for that role (what backend frameworks are used, how they're are used, how is unit testing done, what security practices should be followed, what are the common development design patterns) 

(3) Understanding the overall ecosystem of what you are looking to get a job in (e.g. what cloud provider do you know how to work with, what experience do you have with DevOps, what do you know about software architecture)

I hope that helps you to get an idea of what is required to have good chances for getting a role in tech nowadays. There are many paths you can follow, and the backend development i mentioned is only just one. So maybe start by finding what you want to do, and go from there.",2025-04-28T10:50:26,"['brutal', 'truth', 'knowing', 'programming', 'language', 'mean', 'nothing', '1', 'know', 'role', 'pursue', 'eg', 'backend', 'development', '2', 'know', 'industry', 'standard', 'way', 'thing', 'role', 'backend', 'framework', 'used', 'theyre', 'used', 'unit', 'testing', 'done', 'security', 'practice', 'followed', 'common', 'development', 'design', 'pattern', '3', 'understanding', 'overall', 'ecosystem', 'looking', 'get', 'job', 'eg', 'cloud', 'provider', 'know', 'work', 'experience', 'devops', 'know', 'software', 'architecture', 'hope', 'help', 'get', 'idea', 'required', 'good', 'chance', 'getting', 'role', 'tech', 'nowadays', 'many', 'path', 'follow', 'backend', 'development', 'mentioned', 'one', 'maybe', 'start', 'finding', 'want', 'go']"
Python,"In today's job market, you're going to have a very hard time without a CS degree, and it gets worse every day. Between AI hype and jobs being outsourced to places where the labor is cheap, the competition is intense. It's not impossible, but there are people with 10YOE struggling to find work. Applying to hundreds of jobs is fairly common, and a lot of those will just filter you out without the degree.

Definitely don't do anything hasty.",2025-04-28T11:10:21,"['today', 'job', 'market', 'youre', 'going', 'hard', 'time', 'without', 'c', 'degree', 'get', 'worse', 'every', 'day', 'ai', 'hype', 'job', 'outsourced', 'place', 'labor', 'cheap', 'competition', 'intense', 'impossible', 'people', '10yoe', 'struggling', 'find', 'work', 'applying', 'hundred', 'job', 'fairly', 'common', 'lot', 'filter', 'without', 'degree', 'definitely', 'dont', 'anything', 'hasty']"
Python,"Right now? No. I’m an experienced dev (6 years) with additional experience as a project manager and a marketer. I do everything right — leetcode work, keep my tech skills current, contribute to open source, and even publish, and it still took me nine months to land a gig. Having Python skills ain’t nearly enough right now.",2025-04-28T11:20:57,"['right', 'i’m', 'experienced', 'dev', '6', 'year', 'additional', 'experience', 'project', 'manager', 'marketer', 'everything', 'right', '—', 'leetcode', 'work', 'keep', 'tech', 'skill', 'current', 'contribute', 'open', 'source', 'even', 'publish', 'still', 'took', 'nine', 'month', 'land', 'gig', 'python', 'skill', 'ain’t', 'nearly', 'enough', 'right']"
Python,"Python is a tool that enhances existing skill sets. If you have a CS degree it allows you to apply the concepts you learned there in applications. If you have a mechanical engineering degree, you can apply the calculations and design checks you learned during school and work with code.

English would be extremely niche, you could potentially get work in natural language models, but you shouldn't expect to enroll in a boot camp and have a $100k/year software or web development job, jobs are very competitive now and you need a degree. Furthering those models would require a CS degree, probably a masters. Working with those models would most likely require a connection within an organization doing it already.

Unless you specifically love programming and really want to be a programmer you're probably better off leveraging your skills in an area like marketing or document management/QA/QC for an org that develops reports. I know a decent amount of English teachers that went to law school. Probably a better overlap of your existing skills there.",2025-04-28T10:58:22,"['python', 'tool', 'enhances', 'existing', 'skill', 'set', 'c', 'degree', 'allows', 'apply', 'concept', 'learned', 'application', 'mechanical', 'engineering', 'degree', 'apply', 'calculation', 'design', 'check', 'learned', 'school', 'work', 'code', 'english', 'would', 'extremely', 'niche', 'could', 'potentially', 'get', 'work', 'natural', 'language', 'model', 'shouldnt', 'expect', 'enroll', 'boot', 'camp', '100kyear', 'software', 'web', 'development', 'job', 'job', 'competitive', 'need', 'degree', 'furthering', 'model', 'would', 'require', 'c', 'degree', 'probably', 'master', 'working', 'model', 'would', 'likely', 'require', 'connection', 'within', 'organization', 'already', 'unless', 'specifically', 'love', 'programming', 'really', 'want', 'programmer', 'youre', 'probably', 'better', 'leveraging', 'skill', 'area', 'like', 'marketing', 'document', 'managementqaqc', 'org', 'develops', 'report', 'know', 'decent', 'amount', 'english', 'teacher', 'went', 'law', 'school', 'probably', 'better', 'overlap', 'existing', 'skill']"
Python,I'm an engineer in big tech and have brought a couple of other people over from various career fields. Gotta pay it forward - feel free to reach out,2025-04-28T12:39:46,"['im', 'engineer', 'big', 'tech', 'brought', 'couple', 'people', 'various', 'career', 'field', 'gotta', 'pay', 'forward', 'feel', 'free', 'reach']"
Python,Unfortunately no.  Writing code is only a small part of the job.  Having a decent understanding of systems and architecture is going to be paramaount.  However you can leverage your experience to build interesting tools for teacher or educators.,2025-04-28T17:56:51,"['unfortunately', 'writing', 'code', 'small', 'part', 'job', 'decent', 'understanding', 'system', 'architecture', 'going', 'paramaount', 'however', 'leverage', 'experience', 'build', 'interesting', 'tool', 'teacher', 'educator']"
Python,"Truthfully no. Python is a tool, that’s like saying you’re a mechanic because you can use a drill. If you don’t know industry standards,lingo, and expectations. You’ll just be viewed as a hobbyist.",2025-04-28T16:32:38,"['truthfully', 'python', 'tool', 'that’s', 'like', 'saying', 'you’re', 'mechanic', 'use', 'drill', 'don’t', 'know', 'industry', 'standardslingo', 'expectation', 'you’ll', 'viewed', 'hobbyist']"
Python,"Knowing a programming language is a good start, but these things will help you to land a job:

* Knowing version control systems: learn to use git, create an account on github or gitlab, learn how to create branches, resolve merge conflicts, and create pull requests.
* Knowing about [project management](https://www.atlassian.com/work-management/project-management) and any ticketing system.
* Learn about internet protocols and web development (even if you're going to work just on the backend side): TCP/IP, HTTP, HTML, javascript.
* Read about software design (SOLID principles, patterns, etc).
* Learn about cloud computing (AWS, Gcloud, etc).

That sounds like a lot, but don't worry. You don't need to master all those things, just being able to understand them, and to interact with them.",2025-04-28T18:00:49,"['knowing', 'programming', 'language', 'good', 'start', 'thing', 'help', 'land', 'job', 'knowing', 'version', 'control', 'system', 'learn', 'use', 'git', 'create', 'account', 'github', 'gitlab', 'learn', 'create', 'branch', 'resolve', 'merge', 'conflict', 'create', 'pull', 'request', 'knowing', 'project', 'management', 'ticketing', 'system', 'learn', 'internet', 'protocol', 'web', 'development', 'even', 'youre', 'going', 'work', 'backend', 'side', 'tcpip', 'http', 'html', 'javascript', 'read', 'software', 'design', 'solid', 'principle', 'pattern', 'etc', 'learn', 'cloud', 'computing', 'aws', 'gcloud', 'etc', 'sound', 'like', 'lot', 'dont', 'worry', 'dont', 'need', 'master', 'thing', 'able', 'understand', 'interact']"
Python,no it's not unless you wanna teach it to kids ina a center/academy,2025-04-28T18:24:41,"['unless', 'wanna', 'teach', 'kid', 'ina', 'centeracademy']"
Python,"At this point I would say knowing Python is like knowing Excel. It’s a tool that is so useful in some industries that knowing it is basically a requirement… but nobody gets a job doing just that. 

If you want to be an accountant you NEED to know excel but knowing excel won’t make you an accountant. 

Similarly if you want to be a data scientist you NEED to know Python but knowing Python won’t make you a data scientist.",2025-04-29T01:37:30,"['point', 'would', 'say', 'knowing', 'python', 'like', 'knowing', 'excel', 'it’s', 'tool', 'useful', 'industry', 'knowing', 'basically', 'requirement…', 'nobody', 'get', 'job', 'want', 'accountant', 'need', 'know', 'excel', 'knowing', 'excel', 'won’t', 'make', 'accountant', 'similarly', 'want', 'data', 'scientist', 'need', 'know', 'python', 'knowing', 'python', 'won’t', 'make', 'data', 'scientist']"
Python,"Absolutely not. I programmed as a scientific developer in python for 20 years and I myself have troubles landing a job as a python developer, and the reason is that they don't want you to know python. They want you to know python, keras, pandas, tensorflow, requests, pytorch, numpy, multiprocessing, cython, pytest, uvicorn, fastapi, uv, black, mypy, bash, powershell, MVC, react, redux, typescript, aws, lambda, cloudformation, redis, postgres, aurora, snowflake, github, github actions, scrum, jira, docker, CI/CD, kubernetes, terraform. Also be proactive and independent, aka: your own manager, while your manager tracks KPI and writes powerpoint. Oh, and you have to know how to invert a list for the job interview.

Specialisation is over. They don't want an employee. They want a one man army, and pay him like a junior developer.",2025-04-28T12:24:53,"['absolutely', 'programmed', 'scientific', 'developer', 'python', '20', 'year', 'trouble', 'landing', 'job', 'python', 'developer', 'reason', 'dont', 'want', 'know', 'python', 'want', 'know', 'python', 'kera', 'panda', 'tensorflow', 'request', 'pytorch', 'numpy', 'multiprocessing', 'cython', 'pytest', 'uvicorn', 'fastapi', 'uv', 'black', 'mypy', 'bash', 'powershell', 'mvc', 'react', 'redux', 'typescript', 'aws', 'lambda', 'cloudformation', 'redis', 'postgres', 'aurora', 'snowflake', 'github', 'github', 'action', 'scrum', 'jira', 'docker', 'cicd', 'kubernetes', 'terraform', 'also', 'proactive', 'independent', 'aka', 'manager', 'manager', 'track', 'kpi', 'writes', 'powerpoint', 'oh', 'know', 'invert', 'list', 'job', 'interview', 'specialisation', 'dont', 'want', 'employee', 'want', 'one', 'man', 'army', 'pay', 'like', 'junior', 'developer']"
Python,"Have been where you are.  I got my first python job as a low-level contract worker at a research institute from an ad my wife found in the paper.  After about a year and a half building a website for them from scratch, managed to land something at a large company where I learned tons and am now a fully-fledged back-end python developer.  Yes it's enough, but like anything else you're going to need some luck to get what you want and it won't be easy.",2025-04-28T12:01:45,"['got', 'first', 'python', 'job', 'lowlevel', 'contract', 'worker', 'research', 'institute', 'ad', 'wife', 'found', 'paper', 'year', 'half', 'building', 'website', 'scratch', 'managed', 'land', 'something', 'large', 'company', 'learned', 'ton', 'fullyfledged', 'backend', 'python', 'developer', 'yes', 'enough', 'like', 'anything', 'else', 'youre', 'going', 'need', 'luck', 'get', 'want', 'wont', 'easy']"
Python,"I did the same career switch (teaching -> Python developer) but that was ten years ago. I was able to get on with a venture-backed company and get enough experience to get a job somewhere better. 

As many other folks in this thread have observed, with the way the job market is now, it's very unlikely that you'll find anything. Hiring is drastically reduced, and even CS majors with significant internship experience aren't getting roles. It sucks, but that's how it is.

I think where the real interesting opportunity lies for you is in entrepreneurship. Spend time looking at irritating, repititious tasks you have to do in the classroom, then start figuring out how to write software to solve those problems. If you're having to do some irritating task every day (or, even better, every lesson!), other teachers probably are, too, so there's a market for your solution! Start creating solutions with software for these problems. You'll make your teaching life better, maybe create a product that makes you some money, and get meaningful experience and knowledge (and a software portfolio) that will let you work in a tech job in the future.",2025-04-28T23:10:54,"['career', 'switch', 'teaching', 'python', 'developer', 'ten', 'year', 'ago', 'able', 'get', 'venturebacked', 'company', 'get', 'enough', 'experience', 'get', 'job', 'somewhere', 'better', 'many', 'folk', 'thread', 'observed', 'way', 'job', 'market', 'unlikely', 'youll', 'find', 'anything', 'hiring', 'drastically', 'reduced', 'even', 'c', 'major', 'significant', 'internship', 'experience', 'arent', 'getting', 'role', 'suck', 'thats', 'think', 'real', 'interesting', 'opportunity', 'lie', 'entrepreneurship', 'spend', 'time', 'looking', 'irritating', 'repititious', 'task', 'classroom', 'start', 'figuring', 'write', 'software', 'solve', 'problem', 'youre', 'irritating', 'task', 'every', 'day', 'even', 'better', 'every', 'lesson', 'teacher', 'probably', 'there', 'market', 'solution', 'start', 'creating', 'solution', 'software', 'problem', 'youll', 'make', 'teaching', 'life', 'better', 'maybe', 'create', 'product', 'make', 'money', 'get', 'meaningful', 'experience', 'knowledge', 'software', 'portfolio', 'let', 'work', 'tech', 'job', 'future']"
Python,"Have you considered technical writing? A lot of the work is very repetitive and boring... lending itself to automation. Then you can use LaTeX, and maybe Python to speed up data organization into LaTeX",2025-04-28T11:07:16,"['considered', 'technical', 'writing', 'lot', 'work', 'repetitive', 'boring', 'lending', 'automation', 'use', 'latex', 'maybe', 'python', 'speed', 'data', 'organization', 'latex']"
Python,"I’ll give you a little more optimistic take, having done something roughly like what you’re talking about:

Make a Venn diagram. You’re a teacher, so you should LOOOVE that 🙃. Make circles for what you’re good at as a teacher: conveying knowledge, speaking in front of people, planning, dealing with entitled assholes… Probably English-specific stuff, too, like writing or editing. Each circle has a number of people in it, and the number where they all intersect is smaller.

Now add a circle for “Python” to that. How many people are in ALL the circles now? Not many. That’s you. In fact, you might be able to construct a diagram where you’re the *only* person left (do you know any foreign languages? That really narrows things down). Now you have your unique identity, the thing that isn’t in competition with *anybody*. Obviously that doesn’t make jobs magically appear but it does give you a way to talk about yourself in a way that differentiates you. And it helps frame your thinking about the kind of job you want to pursue.

Off the cuff, I would suggest definitely studying (I mean really *studying*) Python or whatever. But where you’ll find more leverage is something like product management or product marketing. A lot of coders (wrongly) look down on those jobs, since they require a more fused skill set that *you have*. Go to networking events for that sort of thing, tell people exactly the transition you’re trying to make.

And once you get a position doing something like that, it gets you much closer to coding, if that’s (still) what you really want. Which enables the next step, etc.

One more thing: *This may take a while*. You might be talking 5 years before you look around and realize, “Hey, I made it.” You might get lucky and skip a bunch of steps, but probably not. It’s a bit of a walk, but it *can* be done.",2025-04-28T11:34:36,"['i’ll', 'give', 'little', 'optimistic', 'take', 'done', 'something', 'roughly', 'like', 'you’re', 'talking', 'make', 'venn', 'diagram', 'you’re', 'teacher', 'looove', 'make', 'circle', 'you’re', 'good', 'teacher', 'conveying', 'knowledge', 'speaking', 'front', 'people', 'planning', 'dealing', 'entitled', 'assholes…', 'probably', 'englishspecific', 'stuff', 'like', 'writing', 'editing', 'circle', 'number', 'people', 'number', 'intersect', 'smaller', 'add', 'circle', '“python”', 'many', 'people', 'circle', 'many', 'that’s', 'fact', 'might', 'able', 'construct', 'diagram', 'you’re', 'person', 'left', 'know', 'foreign', 'language', 'really', 'narrow', 'thing', 'unique', 'identity', 'thing', 'isn’t', 'competition', 'anybody', 'obviously', 'doesn’t', 'make', 'job', 'magically', 'appear', 'give', 'way', 'talk', 'way', 'differentiates', 'help', 'frame', 'thinking', 'kind', 'job', 'want', 'pursue', 'cuff', 'would', 'suggest', 'definitely', 'studying', 'mean', 'really', 'studying', 'python', 'whatever', 'you’ll', 'find', 'leverage', 'something', 'like', 'product', 'management', 'product', 'marketing', 'lot', 'coder', 'wrongly', 'look', 'job', 'since', 'require', 'fused', 'skill', 'set', 'go', 'networking', 'event', 'sort', 'thing', 'tell', 'people', 'exactly', 'transition', 'you’re', 'trying', 'make', 'get', 'position', 'something', 'like', 'get', 'much', 'closer', 'coding', 'that’s', 'still', 'really', 'want', 'enables', 'next', 'step', 'etc', 'one', 'thing', 'may', 'take', 'might', 'talking', '5', 'year', 'look', 'around', 'realize', '“hey', 'made', 'it”', 'might', 'get', 'lucky', 'skip', 'bunch', 'step', 'probably', 'it’s', 'bit', 'walk', 'done']"
Python,"Creating games is maybe one field where you can benefit from learning one (and only one) language. But that language wouldn't be python, it would be tied to whichever gaming engine you decide to learn.

Good luck!",2025-04-28T10:56:27,"['creating', 'game', 'maybe', 'one', 'field', 'benefit', 'learning', 'one', 'one', 'language', 'language', 'wouldnt', 'python', 'would', 'tied', 'whichever', 'gaming', 'engine', 'decide', 'learn', 'good', 'luck']"
Python,"If you have teaching skills and are technical enough to learn some programming, why not shoot for a project manager or product manager?",2025-04-28T11:37:10,"['teaching', 'skill', 'technical', 'enough', 'learn', 'programming', 'shoot', 'project', 'manager', 'product', 'manager']"
Python,I would consider blending your experiences and consider teaching python.  Private programming lessons for teenagers would earn a very good hourly rate.,2025-04-28T13:48:55,"['would', 'consider', 'blending', 'experience', 'consider', 'teaching', 'python', 'private', 'programming', 'lesson', 'teenager', 'would', 'earn', 'good', 'hourly', 'rate']"
Python,"As a high school student who has been programming for about five years and has built education tools used by two division one colleges, having an English teacher that has a basic understanding of imperative logic would be incredible. I don't know if your Python skills are good enough for a career change, but I can say for sure that good teachers are few and far between. If you are a good teacher, I would really suggest sticking around.",2025-04-28T17:54:19,"['high', 'school', 'student', 'programming', 'five', 'year', 'built', 'education', 'tool', 'used', 'two', 'division', 'one', 'college', 'english', 'teacher', 'basic', 'understanding', 'imperative', 'logic', 'would', 'incredible', 'dont', 'know', 'python', 'skill', 'good', 'enough', 'career', 'change', 'say', 'sure', 'good', 'teacher', 'far', 'good', 'teacher', 'would', 'really', 'suggest', 'sticking', 'around']"
Python,"Absolutely not. Especially in this job market climate. 

At this time, you’ll need a CS degree, relevant job experience, and interviewing skills.

It’s really not the time to get into tech rn",2025-04-28T18:10:47,"['absolutely', 'especially', 'job', 'market', 'climate', 'time', 'you’ll', 'need', 'c', 'degree', 'relevant', 'job', 'experience', 'interviewing', 'skill', 'it’s', 'really', 'time', 'get', 'tech', 'rn']"
Python,absolutely not.  python is useful but is just one skill in the toolbox of any developer.  people who only use python at work usually have another primary skillset like data science or ml.,2025-04-28T18:47:17,"['absolutely', 'python', 'useful', 'one', 'skill', 'toolbox', 'developer', 'people', 'use', 'python', 'work', 'usually', 'another', 'primary', 'skillset', 'like', 'data', 'science', 'ml']"
Python,"I quit teaching exactly 3 years ago and I’m starting in two weeks at FAANG. It is possible, you’ve got to put in the work though. Don’t listen to the doomers.",2025-05-01T02:47:01,"['quit', 'teaching', 'exactly', '3', 'year', 'ago', 'i’m', 'starting', 'two', 'week', 'faang', 'possible', 'you’ve', 'got', 'put', 'work', 'though', 'don’t', 'listen', 'doomers']"
Python,"I was a teacher for four years. One summer, I got a Comptia A+ certification, learned python (Learn Python the Hard Way) and basic web development (Udacity). It was enough to get me an entry level job in software support. I'm still in tech 10 years later and make  triple what I did as a teacher. 

You can do it.",2025-04-28T11:26:29,"['teacher', 'four', 'year', 'one', 'summer', 'got', 'comptia', 'certification', 'learned', 'python', 'learn', 'python', 'hard', 'way', 'basic', 'web', 'development', 'udacity', 'enough', 'get', 'entry', 'level', 'job', 'software', 'support', 'im', 'still', 'tech', '10', 'year', 'later', 'make', 'triple', 'teacher']"
Python,No. Not at all.,2025-04-28T10:59:43,[]
Python,No,2025-04-28T11:16:52,[]
Python,"5 years ago, it probably could work with the right company and if you had some projects you could use as a portfolio.  Market is tough, and hiring is very hard due to fake applicants, liars, and saturation.  It wouldn’t be impossible, but you’d have to be exceptionally good and also find the right company.  Best of luck. ",2025-04-28T10:57:56,"['5', 'year', 'ago', 'probably', 'could', 'work', 'right', 'company', 'project', 'could', 'use', 'portfolio', 'market', 'tough', 'hiring', 'hard', 'due', 'fake', 'applicant', 'liar', 'saturation', 'wouldn’t', 'impossible', 'you’d', 'exceptionally', 'good', 'also', 'find', 'right', 'company', 'best', 'luck']"
Python,"my move from teaching to software development story might not be as relevant these days. 15 years ago, I was faced with layoffs being a relatively new teacher during budget cuts. I put out teaching and programming resumes and was able to get a couple of interviews by way of a recruiter, and a start-up took me on. Best thing, career wise, to ever happen to me. 

Why did they take me on? Because I had independent projects that I could talk about mostly. The course supplies sharing website I made for us teachers while we designed a new curriculum was the most relevant. But I could talk about a couple toy customer management solution projects I had put out. I could talk intelligently enough about shipping php and mysql projects (go LAMP stack) and could answer the four different interviewer's questions mostly around from some js and html/css stuff. I had read a couple programming books, web design books, and was passingly familiar with mysql -- I could left join :goldstar: :haha:.  Amazingly, they took me on as a mid-level developer.  I had never even heard of a unit test, though that didn't come up in the interview.

Best of luck!",2025-04-28T11:28:43,"['move', 'teaching', 'software', 'development', 'story', 'might', 'relevant', 'day', '15', 'year', 'ago', 'faced', 'layoff', 'relatively', 'new', 'teacher', 'budget', 'cut', 'put', 'teaching', 'programming', 'resume', 'able', 'get', 'couple', 'interview', 'way', 'recruiter', 'startup', 'took', 'best', 'thing', 'career', 'wise', 'ever', 'happen', 'take', 'independent', 'project', 'could', 'talk', 'mostly', 'course', 'supply', 'sharing', 'website', 'made', 'u', 'teacher', 'designed', 'new', 'curriculum', 'relevant', 'could', 'talk', 'couple', 'toy', 'customer', 'management', 'solution', 'project', 'put', 'could', 'talk', 'intelligently', 'enough', 'shipping', 'php', 'mysql', 'project', 'go', 'lamp', 'stack', 'could', 'answer', 'four', 'different', 'interviewer', 'question', 'mostly', 'around', 'j', 'htmlcss', 'stuff', 'read', 'couple', 'programming', 'book', 'web', 'design', 'book', 'passingly', 'familiar', 'mysql', 'could', 'left', 'join', 'goldstar', 'haha', 'amazingly', 'took', 'midlevel', 'developer', 'never', 'even', 'heard', 'unit', 'test', 'though', 'didnt', 'come', 'interview', 'best', 'luck']"
Python,"Just Python? No. Most jobs that involve Python require a bunch of other skills/tools to be useful, even fresh graduates should have some of those skills.

I don't think a career switch is impossible and you'll probably get some leniance for having a decade of work experience. What I would suggest is building something small from start to finish and doing a reasonable job at all aspects of it.

Let's say you wanted to get a backend dev job (that's what I do), then having a small REST API under your belt would make a big difference. If you can demonstrate having done not just Python code, but documentation, testing, using version control, familiarity with a framework, used a database, and some cloud services knowledge, then you'd have a reasonable chance.",2025-04-28T11:30:05,"['python', 'job', 'involve', 'python', 'require', 'bunch', 'skillstools', 'useful', 'even', 'fresh', 'graduate', 'skill', 'dont', 'think', 'career', 'switch', 'impossible', 'youll', 'probably', 'get', 'leniance', 'decade', 'work', 'experience', 'would', 'suggest', 'building', 'something', 'small', 'start', 'finish', 'reasonable', 'job', 'aspect', 'let', 'say', 'wanted', 'get', 'backend', 'dev', 'job', 'thats', 'small', 'rest', 'api', 'belt', 'would', 'make', 'big', 'difference', 'demonstrate', 'done', 'python', 'code', 'documentation', 'testing', 'using', 'version', 'control', 'familiarity', 'framework', 'used', 'database', 'cloud', 'service', 'knowledge', 'youd', 'reasonable', 'chance']"
Python,"If you want to change your career to Software Engineer, I would strongly recommend start from it manager or junior data analyst/ data scientist. Or automated testing engineer. Strong skills with Python and Sql and database systems will be enough for junior positions. 

Ps: I know it might sound usual but, if you rerolling just because of money or something else, not the passion or enthusiasm to constantly learn and improve. Like doing your job as a lifestyle every day and every where. If you feel that, Do it! 
If not there is a lot of other things you can do with much less effort.",2025-04-28T11:35:33,"['want', 'change', 'career', 'software', 'engineer', 'would', 'strongly', 'recommend', 'start', 'manager', 'junior', 'data', 'analyst', 'data', 'scientist', 'automated', 'testing', 'engineer', 'strong', 'skill', 'python', 'sql', 'database', 'system', 'enough', 'junior', 'position', 'p', 'know', 'might', 'sound', 'usual', 'rerolling', 'money', 'something', 'else', 'passion', 'enthusiasm', 'constantly', 'learn', 'improve', 'like', 'job', 'lifestyle', 'every', 'day', 'every', 'feel', 'lot', 'thing', 'much', 'less', 'effort']"
Python,What country are you based,2025-04-28T11:50:56,"['country', 'based']"
Python,"Try visiting r/learnpython. You could pick it up just for fun for now, but to be real with you it takes a couple years of self-learning realistically and a fortunate job market to make the switch (which we don’t have right now. People seem to flock to becoming a software engineer as an overnight solution for jobs they hate, but it takes time. 

I did just this and it took about two years and I’d say I was lucky to land a job. Still thankful for it. 

Here’s what you could do though. You could pick up some lighter skills and try to get into a large corporation in a non-technical role. Seek out project management, a governance role (maybe ITIL related), or something in operations management. Then you can breathe easier and begin to network and make contacts as you begin to upskilling technically if that’s still what you’d like to do.",2025-04-28T11:54:27,"['try', 'visiting', 'rlearnpython', 'could', 'pick', 'fun', 'real', 'take', 'couple', 'year', 'selflearning', 'realistically', 'fortunate', 'job', 'market', 'make', 'switch', 'don’t', 'right', 'people', 'seem', 'flock', 'becoming', 'software', 'engineer', 'overnight', 'solution', 'job', 'hate', 'take', 'time', 'took', 'two', 'year', 'i’d', 'say', 'lucky', 'land', 'job', 'still', 'thankful', 'here’s', 'could', 'though', 'could', 'pick', 'lighter', 'skill', 'try', 'get', 'large', 'corporation', 'nontechnical', 'role', 'seek', 'project', 'management', 'governance', 'role', 'maybe', 'itil', 'related', 'something', 'operation', 'management', 'breathe', 'easier', 'begin', 'network', 'make', 'contact', 'begin', 'upskilling', 'technically', 'that’s', 'still', 'you’d', 'like']"
Python,"Python is the Lingua Franca of data science.


So the way to approach this might be:
-im interested in a grad role in this analytics team, and I have this python skill to offer


It's something which is a great skill to have but you still need to advance your experience on the job in the normal way.


Possible areas to look into:
Analytics, data science.",2025-04-28T12:12:48,"['python', 'lingua', 'franca', 'data', 'science', 'way', 'approach', 'might', 'im', 'interested', 'grad', 'role', 'analytics', 'team', 'python', 'skill', 'offer', 'something', 'great', 'skill', 'still', 'need', 'advance', 'experience', 'job', 'normal', 'way', 'possible', 'area', 'look', 'analytics', 'data', 'science']"
Python,"I absolutely would NOT learn a language in anticipation that I'd get a job. In the current market, you need to be an engineer to have value. I can't begin to predict the future market.",2025-04-28T12:37:29,"['absolutely', 'would', 'learn', 'language', 'anticipation', 'id', 'get', 'job', 'current', 'market', 'need', 'engineer', 'value', 'cant', 'begin', 'predict', 'future', 'market']"
Python,"Other people have already said that it’s gonna be hard without a degree.

Apart from that, I’m not sure python specifically is beneficial as a choice. It’s great for machine learning and scripting but also not used in many „simpler“ products. Also it’s the entry language for many students so you’d compete with.

So you’d compete with many people for few jobs.",2025-04-28T12:37:42,"['people', 'already', 'said', 'it’s', 'gonna', 'hard', 'without', 'degree', 'apart', 'i’m', 'sure', 'python', 'specifically', 'beneficial', 'choice', 'it’s', 'great', 'machine', 'learning', 'scripting', 'also', 'used', 'many', '„simpler“', 'product', 'also', 'it’s', 'entry', 'language', 'many', 'student', 'you’d', 'compete', 'you’d', 'compete', 'many', 'people', 'job']"
Python,Which country?,2025-04-28T12:45:59,['country']
Python,"No but it's a good first step...   just knowing some python is akin to having creds as a substitute teacher and wanting to get into teaching, you have a ways to go.",2025-04-28T13:19:55,"['good', 'first', 'step', 'knowing', 'python', 'akin', 'cred', 'substitute', 'teacher', 'wanting', 'get', 'teaching', 'way', 'go']"
Python,Any visual arts skills? Animation (including VFX) is a possible option.,2025-04-28T13:31:24,"['visual', 'art', 'skill', 'animation', 'including', 'vfx', 'possible', 'option']"
Python,"Knowing the basic language? No. Pick what area you want to go into and start picking up online or local college courses that fit. 

Data analytics is big and will continue to be. Pandas is a great way to query and work with data. Investigate and see if that's an area you might be interested and then maybe just pick up a book and start working with it?",2025-04-28T14:01:36,"['knowing', 'basic', 'language', 'pick', 'area', 'want', 'go', 'start', 'picking', 'online', 'local', 'college', 'course', 'fit', 'data', 'analytics', 'big', 'continue', 'panda', 'great', 'way', 'query', 'work', 'data', 'investigate', 'see', 'thats', 'area', 'might', 'interested', 'maybe', 'pick', 'book', 'start', 'working']"
Python,"I was in a similar position, working at a school, learned to code and eventually moved to industry.


It's hard, as others have mentioned. What really helped was learning and using the auxiliary tools, like docker and git. And writing, deploying and maintaining an online registration tool for the school was a big help. 


Interesting for me the hardest part was getting in a more commercial mindset. That kind of thinking didn't exist in the school, and took quite a shift in moving out. Actions often need to be framed around the needs of the business, which are very different to the needs of a school",2025-04-28T14:08:54,"['similar', 'position', 'working', 'school', 'learned', 'code', 'eventually', 'moved', 'industry', 'hard', 'others', 'mentioned', 'really', 'helped', 'learning', 'using', 'auxiliary', 'tool', 'like', 'docker', 'git', 'writing', 'deploying', 'maintaining', 'online', 'registration', 'tool', 'school', 'big', 'help', 'interesting', 'hardest', 'part', 'getting', 'commercial', 'mindset', 'kind', 'thinking', 'didnt', 'exist', 'school', 'took', 'quite', 'shift', 'moving', 'action', 'often', 'need', 'framed', 'around', 'need', 'business', 'different', 'need', 'school']"
Python,"Look for jobs where the classroom skills set you apart.  Think of any software you used, saw, or talked about while teaching.  All those may really value a junior engineer with classroom insidght, especially startups in the education space.",2025-04-28T14:10:57,"['look', 'job', 'classroom', 'skill', 'set', 'apart', 'think', 'software', 'used', 'saw', 'talked', 'teaching', 'may', 'really', 'value', 'junior', 'engineer', 'classroom', 'insidght', 'especially', 'startup', 'education', 'space']"
Python,No,2025-04-28T14:14:05,[]
Python,you could definitely leverage your experience into a developer relations/devrel job or a technical writing one. you will have to be creative about explaining how your skills transfer but it's doable.,2025-04-28T14:14:14,"['could', 'definitely', 'leverage', 'experience', 'developer', 'relationsdevrel', 'job', 'technical', 'writing', 'one', 'creative', 'explaining', 'skill', 'transfer', 'doable']"
Python,No. Learn ml then yes,2025-04-28T14:14:41,"['learn', 'ml', 'yes']"
Python,"Without any experience in the tech world using python and sql, probably not. There’s people with masters and phds in data science that can’t find jobs right now.

And if I interviewed you, I don’t care if you ‘know’ python; only that you’ve done something _with_ python that solved some problem, and that you can be articulate about it.",2025-04-28T14:16:04,"['without', 'experience', 'tech', 'world', 'using', 'python', 'sql', 'probably', 'there’s', 'people', 'master', 'phd', 'data', 'science', 'can’t', 'find', 'job', 'right', 'interviewed', 'don’t', 'care', '‘know’', 'python', 'you’ve', 'done', 'something', 'python', 'solved', 'problem', 'articulate']"
Python,"So, as a teacher, think about breaking into tech by doing technical writing, technical training, or customer support. Learning Python to build a technical writing portfolio will be different than learning Python to build a programming job portfolio, but will show that you have technical skills.

Depending on what local companies are doing, programming may not be the most important tech skill. You might consider learning about “the cloud” instead or in additoon [https://aws.amazon.com/training/skills-centers/](https://aws.amazon.com/training/skills-centers/)

Be aware that getting your first job in tech as a non traditional candidate will be hard, and a tough tech job market will make it harder.",2025-04-28T14:36:41,"['teacher', 'think', 'breaking', 'tech', 'technical', 'writing', 'technical', 'training', 'customer', 'support', 'learning', 'python', 'build', 'technical', 'writing', 'portfolio', 'different', 'learning', 'python', 'build', 'programming', 'job', 'portfolio', 'show', 'technical', 'skill', 'depending', 'local', 'company', 'programming', 'may', 'important', 'tech', 'skill', 'might', 'consider', 'learning', '“the', 'cloud”', 'instead', 'additoon', 'aware', 'getting', 'first', 'job', 'tech', 'non', 'traditional', 'candidate', 'hard', 'tough', 'tech', 'job', 'market', 'make', 'harder']"
Python,That is where I started as a teacher - got me a research associate position (physics degree helped lol) and then data science and now data engineering,2025-04-28T14:38:06,"['started', 'teacher', 'got', 'research', 'associate', 'position', 'physic', 'degree', 'helped', 'lol', 'data', 'science', 'data', 'engineering']"
Python,"Why do a complete 180? If you're and english teacher you're bound to have great language and writing skills. Coupled with an interest for technical things and programming, why not apply to jobs writing technical documentation or user manuals? If you know programming and git basics you might even be able to interact with tooling the company uses.

People like these are rare hard to find, maybe you can give that a try.",2025-04-28T15:20:08,"['complete', '180', 'youre', 'english', 'teacher', 'youre', 'bound', 'great', 'language', 'writing', 'skill', 'coupled', 'interest', 'technical', 'thing', 'programming', 'apply', 'job', 'writing', 'technical', 'documentation', 'user', 'manual', 'know', 'programming', 'git', 'basic', 'might', 'even', 'able', 'interact', 'tooling', 'company', 'us', 'people', 'like', 'rare', 'hard', 'find', 'maybe', 'give', 'try']"
Python,"In 2025 your best (and probably the only as well ) bet is to develop an AI-based project to solve a real problem in education.
Buy a $20 ChatGPT sub and talk to it.


Within few years education will be totally different - teaching will be done by AI while teachers will become guides, mentors or even friends for the kids. ",2025-04-28T15:38:20,"['2025', 'best', 'probably', 'well', 'bet', 'develop', 'aibased', 'project', 'solve', 'real', 'problem', 'education', 'buy', '20', 'chatgpt', 'sub', 'talk', 'within', 'year', 'education', 'totally', 'different', 'teaching', 'done', 'ai', 'teacher', 'become', 'guide', 'mentor', 'even', 'friend', 'kid']"
Python,"I would say that python is a skill, not a career. Now if you got really good with pyval or some scientific tooling or debugging with Python there might be a chance but even that industry is being hit hard be layoffs",2025-04-28T15:41:30,"['would', 'say', 'python', 'skill', 'career', 'got', 'really', 'good', 'pyval', 'scientific', 'tooling', 'debugging', 'python', 'might', 'chance', 'even', 'industry', 'hit', 'hard', 'layoff']"
Python,"Yes as long as the job isn't centered on knowing Python. Python is the tool, and just like how you wouldn't become a mechanic just by ""knowing wrenches,"" you would need experience building things to get the job. 

There are many jobs where a little programming goes a long way. I can't tell you the number of times I've saved myself hours of work by writing a few lines of code, and no shortage of non technical jobs have those sorts of problems. 

Personally, I'd recommend learning python because it's useful and fun, and don't sweat how it specifically plays into your career plans until they are more concrete.",2025-04-28T15:48:31,"['yes', 'long', 'job', 'isnt', 'centered', 'knowing', 'python', 'python', 'tool', 'like', 'wouldnt', 'become', 'mechanic', 'knowing', 'wrench', 'would', 'need', 'experience', 'building', 'thing', 'get', 'job', 'many', 'job', 'little', 'programming', 'go', 'long', 'way', 'cant', 'tell', 'number', 'time', 'ive', 'saved', 'hour', 'work', 'writing', 'line', 'code', 'shortage', 'non', 'technical', 'job', 'sort', 'problem', 'personally', 'id', 'recommend', 'learning', 'python', 'useful', 'fun', 'dont', 'sweat', 'specifically', 'play', 'career', 'plan', 'concrete']"
Python,"Sounds like a library that misbehaved badly, but also why are you still on 3.8? It has been EOL since last October...",2025-04-27T23:33:59,"['sound', 'like', 'library', 'misbehaved', 'badly', 'also', 'still', '38', 'eol', 'since', 'last', 'october']"
Python,"Yeah, ideally I'd argue that only `__str__` should exist and support all the formatting, including `repr` functionality.
Would love to have ""formatting options"" for repr too, like requesting a representation as executable python code.",2025-04-27T17:25:26,"['yeah', 'ideally', 'id', 'argue', 'str', 'exist', 'support', 'formatting', 'including', 'repr', 'functionality', 'would', 'love', 'formatting', 'option', 'repr', 'like', 'requesting', 'representation', 'executable', 'python', 'code']"
Python,"Interesting read, thanks :)",2025-04-27T19:31:45,"['interesting', 'read', 'thanks']"
Python,"Temporal user here who has also been affected by the sandbox, I feel you pain! Very interesting read!",2025-04-28T03:43:48,"['temporal', 'user', 'also', 'affected', 'sandbox', 'feel', 'pain', 'interesting', 'read']"
Python,"I built a container the other day and started getting errors where double apostrophes were used instead of single, but the code ran fine for months when it was ran from the command line. So something like this is wrong: f“Number of datasets: {results.get(“total”)}” - needs to be ‘total’. So that was fun.",2025-04-28T09:28:40,"['built', 'container', 'day', 'started', 'getting', 'error', 'double', 'apostrophe', 'used', 'instead', 'single', 'code', 'ran', 'fine', 'month', 'ran', 'command', 'line', 'something', 'like', 'wrong', 'f“number', 'datasets', 'resultsget“total””', 'need', '‘total’', 'fun']"
Python,"Well, okay, but rather than lamenting your ""lost 3 hours,"" what are your key takeaways so it doesn't cost you three hours next time?",2025-04-28T12:36:42,"['well', 'okay', 'rather', 'lamenting', 'lost', '3', 'hour', 'key', 'takeaway', 'doesnt', 'cost', 'three', 'hour', 'next', 'time']"
Python,"Have you ever try ""uvx pyinstrument yourapp.py"" ?",2025-04-28T21:43:04,"['ever', 'try', 'uvx', 'pyinstrument', 'yourapppy']"
Python,"FYI, we are working on an update to line-profiler where you will specify the module you want to profile (which could be your entire app), and it will effectively insert the decorators for you using AST magic. 

It currently has the ability to do this, but the behavior is a bit weird. Technically right now you can do something like:

    cd ""$(python -c ""import uuid, os; print(os.path.dirname(uuid.__file__))"")""
    kernprof -lvr -p uuid.py uuid.py

To tell it to run the uuid.py script and also profile it. Adding the `-vr` will make it pretty-print results at the end. 

E.g.


    Total time: 2.9e-06 s
    File: uuid.py
    Function: __str__ at line 283
    
    Line #      Hits         Time  Per Hit   % Time  Line Contents
    ==============================================================
       283                                               def __str__(self):                                           
       284         1          1.5      1.5     50.6          hex = '%032x' % self.int                                 
       285         1          0.7      0.7     23.0          return '%s-%s-%s-%s-%s' % (                              
       286         1          0.8      0.8     26.3              hex[:8], hex[8:12], hex[12:16], hex[16:20], hex[20:])
    

I'm thining for the 5.x release we may make changes to the defaults so the common use-case will look more like:

`kernprof -p uuid -m uuid` 

or even just

`kernprof -m uuid` 

if you have a pyproject.toml that lists the modules you want profiled.",2025-04-29T01:34:25,"['fyi', 'working', 'update', 'lineprofiler', 'specify', 'module', 'want', 'profile', 'could', 'entire', 'app', 'effectively', 'insert', 'decorator', 'using', 'ast', 'magic', 'currently', 'ability', 'behavior', 'bit', 'weird', 'technically', 'right', 'something', 'like', 'cd', 'python', 'c', 'import', 'uuid', 'o', 'printospathdirnameuuidfile', 'kernprof', 'lvr', 'p', 'uuidpy', 'uuidpy', 'tell', 'run', 'uuidpy', 'script', 'also', 'profile', 'adding', 'vr', 'make', 'prettyprint', 'result', 'end', 'eg', 'total', 'time', '29e06', 'file', 'uuidpy', 'function', 'str', 'line', '283', 'line', 'hit', 'time', 'per', 'hit', 'time', 'line', 'content', '283', 'def', 'strself', '284', '1', '15', '15', '506', 'hex', '032x', 'selfint', '285', '1', '07', '07', '230', 'return', 'sssss', '286', '1', '08', '08', '263', 'hex8', 'hex812', 'hex1216', 'hex1620', 'hex20', 'im', 'thining', '5x', 'release', 'may', 'make', 'change', 'default', 'common', 'usecase', 'look', 'like', 'kernprof', 'p', 'uuid', 'uuid', 'even', 'kernprof', 'uuid', 'pyprojecttoml', 'list', 'module', 'want', 'profiled']"
Python,Good clean code. You demonstrate a solid understanding of python and of tracing tools. I’ve been developing in python for a long time and you taught me some things.,2025-04-29T03:14:20,"['good', 'clean', 'code', 'demonstrate', 'solid', 'understanding', 'python', 'tracing', 'tool', 'i’ve', 'developing', 'python', 'long', 'time', 'taught', 'thing']"
Python,"For some of the kinds of problems you're aiming to solve, I've usually found I can get good results with Py-Spy. What's your take on it?",2025-04-28T23:09:24,"['kind', 'problem', 'youre', 'aiming', 'solve', 'ive', 'usually', 'found', 'get', 'good', 'result', 'pyspy', 'whats', 'take']"
Python,"*The interactive terminal is based on built in library curses*

Goodbye Windows 😅

But in OP's defense, afaik, there's not much real equivalent for Windows, at least one that is still maintained and doesn't have way too many dependencies.",2025-04-29T08:20:31,"['interactive', 'terminal', 'based', 'built', 'library', 'curse', 'goodbye', 'window', 'ops', 'defense', 'afaik', 'there', 'much', 'real', 'equivalent', 'window', 'least', 'one', 'still', 'maintained', 'doesnt', 'way', 'many', 'dependency']"
Python,"Ah yes, Python, my language of choice for speed

Seriously though, cool project and it’ll satisfy my curiosity if nothing else",2025-04-29T06:54:42,"['ah', 'yes', 'python', 'language', 'choice', 'speed', 'seriously', 'though', 'cool', 'project', 'it’ll', 'satisfy', 'curiosity', 'nothing', 'else']"
Python,"There are lots of different ways to measure performance. If you care about a specific workload, you'll have to benchmark it yourself.

There are various resources that compare performance between different Python versions or describe optimization work:

* https://lost.co.nz/articles/sixteen-years-of-python-performance/
* https://speed.python.org/
* https://github.com/faster-cpython ← includes archives of benchmark results

The TL;DR is that CPython tends to make performance improvements with every release, though individual benchmarks might see regressions. Historically, there was a large regression when switching to Python 3, but that is irrelevant now. Python 3.11 saw significant work on performance (reported as 25% average uplift in the [release notes](https://docs.python.org/3/whatsnew/3.11.html#whatsnew311-faster-cpython)).

While you can expect Python 3.13 to be a bit faster, it focused on laying the groundwork for larger optimizations in the future (JIT, free-threaded mode). Those features are too experimental to be used in production, though.

If you care about the last 5% of performance, I'd recommend compiling Python yourself with optimizations for your specific CPU architecture. Pre-built binaries tend to sacrifice a bit of performance for broader compatibility.",2025-04-27T09:11:09,"['lot', 'different', 'way', 'measure', 'performance', 'care', 'specific', 'workload', 'youll', 'benchmark', 'various', 'resource', 'compare', 'performance', 'different', 'python', 'version', 'describe', 'optimization', 'work', '←', 'includes', 'archive', 'benchmark', 'result', 'tldr', 'cpython', 'tends', 'make', 'performance', 'improvement', 'every', 'release', 'though', 'individual', 'benchmark', 'might', 'see', 'regression', 'historically', 'large', 'regression', 'switching', 'python', '3', 'irrelevant', 'python', '311', 'saw', 'significant', 'work', 'performance', 'reported', '25', 'average', 'uplift', 'release', 'note', 'expect', 'python', '313', 'bit', 'faster', 'focused', 'laying', 'groundwork', 'larger', 'optimization', 'future', 'jit', 'freethreaded', 'mode', 'feature', 'experimental', 'used', 'production', 'though', 'care', 'last', '5', 'performance', 'id', 'recommend', 'compiling', 'python', 'optimization', 'specific', 'cpu', 'architecture', 'prebuilt', 'binary', 'tend', 'sacrifice', 'bit', 'performance', 'broader', 'compatibility']"
Python,This sounds like the sort of thing you could do some benchmarks on and share your results for the next person and to get technical feedback on the outcomes.,2025-04-27T08:43:48,"['sound', 'like', 'sort', 'thing', 'could', 'benchmark', 'share', 'result', 'next', 'person', 'get', 'technical', 'feedback', 'outcome']"
Python,I love how everyone is replying to just test it yourself as if this is some crazy concept that nobody would have an answer to. I mean I'm not gonna go do it but I'm sure someone out there knows and it's not thay crazy of an ask lol,2025-04-27T12:43:23,"['love', 'everyone', 'replying', 'test', 'crazy', 'concept', 'nobody', 'would', 'answer', 'mean', 'im', 'gonna', 'go', 'im', 'sure', 'someone', 'know', 'thay', 'crazy', 'ask', 'lol']"
Python,"For my use cases (ML/AI pipelines) the performance has improved a bit between 3.10 to 3.13, but it doesn’t really matter. What really matters is carefully coded, vectorized matrix operations (avoiding for loops and iterrows), profiling and optimizing each transformation steps; and switching from pandas to polars (this latter is responsible for a 40x speedup alone).",2025-04-27T09:23:11,"['use', 'case', 'mlai', 'pipeline', 'performance', 'improved', 'bit', '310', '313', 'doesn’t', 'really', 'matter', 'really', 'matter', 'carefully', 'coded', 'vectorized', 'matrix', 'operation', 'avoiding', 'loop', 'iterrows', 'profiling', 'optimizing', 'transformation', 'step', 'switching', 'panda', 'polars', 'latter', 'responsible', '40x', 'speedup', 'alone']"
Python,"Not thoughts, just metrics. Carve out some code, run it and as u/nekokattt suggested, share here.",2025-04-27T09:11:46,"['thought', 'metric', 'carve', 'code', 'run', 'unekokattt', 'suggested', 'share']"
Python,"Performance is noticeably better for me.
I've been makiing [my game](https://store.steampowered.com/app/3122220/Mr_Figs) for the last 4 years in Python/Pygame. When I jumped from 3.12 to 3.13 there was noticeable improvements even without benchmarking.

The FPS counter was about 5/6 FPS higher. A big win for a game and a huge win for stuff that isn't so intense.

I'd upgrade if you can and like others have said, benchmark it. The `time` module is good and so is `scalene` if you want to run a profiler on it.",2025-04-27T17:58:17,"['performance', 'noticeably', 'better', 'ive', 'makiing', 'game', 'last', '4', 'year', 'pythonpygame', 'jumped', '312', '313', 'noticeable', 'improvement', 'even', 'without', 'benchmarking', 'fps', 'counter', '56', 'fps', 'higher', 'big', 'win', 'game', 'huge', 'win', 'stuff', 'isnt', 'intense', 'id', 'upgrade', 'like', 'others', 'said', 'benchmark', 'time', 'module', 'good', 'scalene', 'want', 'run', 'profiler']"
Python,"You should mainly care about the performance of the programs you use. I suggest you try running your code on both and compare. If you can’t tell the difference, then it’s fine to upgrade.",2025-04-27T08:46:26,"['mainly', 'care', 'performance', 'program', 'use', 'suggest', 'try', 'running', 'code', 'compare', 'can’t', 'tell', 'difference', 'it’s', 'fine', 'upgrade']"
Python,"Have you tried profiling your code? That's probably your best answer/option, and one of the best reasons to use something like `pyenv` and various associated `venv` on your dev stacks.",2025-04-27T09:55:28,"['tried', 'profiling', 'code', 'thats', 'probably', 'best', 'answeroption', 'one', 'best', 'reason', 'use', 'something', 'like', 'pyenv', 'various', 'associated', 'venv', 'dev', 'stack']"
Python,I hear 3.14159265358979323846264338327950288419716939937510 is very good for math,2025-04-27T16:51:19,"['hear', '314159265358979323846264338327950288419716939937510', 'good', 'math']"
Python,Performance discussion about Python. Thats a joke right?,2025-04-27T11:31:00,"['performance', 'discussion', 'python', 'thats', 'joke', 'right']"
Python,"Quickest and easiest: Flask or FastApi. But if you need a user model, you might prefer learning django for the long term. I don’t know Fast Api well enough, but for flask I recommend flask-admin and flask-security libraries rather than reinventing the wheel",2025-04-30T10:24:06,"['quickest', 'easiest', 'flask', 'fastapi', 'need', 'user', 'model', 'might', 'prefer', 'learning', 'django', 'long', 'term', 'don’t', 'know', 'fast', 'api', 'well', 'enough', 'flask', 'recommend', 'flaskadmin', 'flasksecurity', 'library', 'rather', 'reinventing', 'wheel']"
Python,"I know all three of these and if i had to stand up a full stack app tomorrow I'd just use Django to get it done quick. At this point in the game I'm only using Flask when a project already leveraged it, but not for anything new.

FastAPI for pure API
Django for doing a full fledged app

You'll probably be learning the ORMs alongside both. That'll probably be SQLAlchemy for FastAPI/Flask, and will be Django's ORM. I find Django to be easier. But that's probably because i learned it first",2025-04-30T10:56:44,"['know', 'three', 'stand', 'full', 'stack', 'app', 'tomorrow', 'id', 'use', 'django', 'get', 'done', 'quick', 'point', 'game', 'im', 'using', 'flask', 'project', 'already', 'leveraged', 'anything', 'new', 'fastapi', 'pure', 'api', 'django', 'full', 'fledged', 'app', 'youll', 'probably', 'learning', 'orms', 'alongside', 'thatll', 'probably', 'sqlalchemy', 'fastapiflask', 'djangos', 'orm', 'find', 'django', 'easier', 'thats', 'probably', 'learned', 'first']"
Python,"Django all the way, all day if you want to have user management, admin panel and crud done fast out of the box.

Don't bother if you only intend it for like a couple of endpoints, but django is a great framework that has way more features than any of the other frameworks, it comes with its complexity though.",2025-04-30T11:56:15,"['django', 'way', 'day', 'want', 'user', 'management', 'admin', 'panel', 'crud', 'done', 'fast', 'box', 'dont', 'bother', 'intend', 'like', 'couple', 'endpoint', 'django', 'great', 'framework', 'way', 'feature', 'framework', 'come', 'complexity', 'though']"
Python,"Quickest = FastAPI

Easiest = Flask

Robust and Professional = Django",2025-04-30T15:13:50,"['quickest', 'fastapi', 'easiest', 'flask', 'robust', 'professional', 'django']"
Python,"FastAPI, for it depends on Pydantic.",2025-04-30T10:43:26,"['fastapi', 'depends', 'pydantic']"
Python,fastapi,2025-04-30T10:51:10,['fastapi']
Python,Litestar.,2025-04-30T10:30:39,['litestar']
Python,"Either one is going to work fine, and either one is going to have certain specific things you're going to have to learn to use them. Efficiency from scratch is probably to be rather similar, given that they all have the same features - django just includes more of them in the standard library, while the other ones will either have external modules or things you add as you wish.",2025-04-30T10:40:07,"['either', 'one', 'going', 'work', 'fine', 'either', 'one', 'going', 'certain', 'specific', 'thing', 'youre', 'going', 'learn', 'use', 'efficiency', 'scratch', 'probably', 'rather', 'similar', 'given', 'feature', 'django', 'includes', 'standard', 'library', 'one', 'either', 'external', 'module', 'thing', 'add', 'wish']"
Python,"* Quickest: probably FastAPI. I haven't used it much myself but it's probably the quickest to write with. If you mean quickest in terms of performance, you probably shouldn't be using Python.
* Easiest: doesn't get much easier than Flask. I teach Flask to students with less than 2 months of programming experience and it makes sense to them.

That being said idk much about Firebase so that might change things a little.",2025-04-30T10:42:23,"['quickest', 'probably', 'fastapi', 'havent', 'used', 'much', 'probably', 'quickest', 'write', 'mean', 'quickest', 'term', 'performance', 'probably', 'shouldnt', 'using', 'python', 'easiest', 'doesnt', 'get', 'much', 'easier', 'flask', 'teach', 'flask', 'student', 'less', '2', 'month', 'programming', 'experience', 'make', 'sense', 'said', 'idk', 'much', 'firebase', 'might', 'change', 'thing', 'little']"
Python,If you like flask but want pure async check out Quart,2025-04-30T14:11:35,"['like', 'flask', 'want', 'pure', 'async', 'check', 'quart']"
Python,Starlette,2025-04-30T11:58:47,['starlette']
Python,Litestar,2025-04-30T10:22:13,['litestar']
Python,Definitely FastAPI. And you should also learn and use SQLmodel by the same author with SQLite. And use Uvicorn to serve on some port like 8008 and reverse proxy to Nginx.,2025-04-30T13:19:02,"['definitely', 'fastapi', 'also', 'learn', 'use', 'sqlmodel', 'author', 'sqlite', 'use', 'uvicorn', 'serve', 'port', 'like', '8008', 'reverse', 'proxy', 'nginx']"
Python,Fastapi if you are building API and use JS or others in frontend.....  Django if you are going full-stack...... Btw I chose fast API and never regretted my decision.,2025-04-30T14:37:31,"['fastapi', 'building', 'api', 'use', 'j', 'others', 'frontend', 'django', 'going', 'fullstack', 'btw', 'chose', 'fast', 'api', 'never', 'regretted', 'decision']"
Python,"Flask.

I use this template: [https://github.com/habedi/template-web-app-flask](https://github.com/habedi/template-web-app-flask)",2025-04-30T14:43:59,"['flask', 'use', 'template']"
Python,"Just curious as you have mentioned firebase, I assume your app already connects with firebase so why do you require a different backend?",2025-04-30T16:25:16,"['curious', 'mentioned', 'firebase', 'assume', 'app', 'already', 'connects', 'firebase', 'require', 'different', 'backend']"
Python,"Django if you want something that might get you a job. 

FastAPI for the best experience.",2025-04-30T17:17:09,"['django', 'want', 'something', 'might', 'get', 'job', 'fastapi', 'best', 'experience']"
Python,"Learn Flask to learn wsgi. Know the pitfalls of wsgi, learn FastApi, learn asgi. Know the pitfalls of using barebone libraries. Learn django, get frustrated with its verbosity. Come back to Flask. Rinse and repeat.",2025-04-30T17:45:11,"['learn', 'flask', 'learn', 'wsgi', 'know', 'pitfall', 'wsgi', 'learn', 'fastapi', 'learn', 'asgi', 'know', 'pitfall', 'using', 'barebone', 'library', 'learn', 'django', 'get', 'frustrated', 'verbosity', 'come', 'back', 'flask', 'rinse', 'repeat']"
Python,"I'd recommend fast-api, its the shiny new equivalent of flask. Less familiar with Django but I believe its a more used as a full stack (frontend and backend). In my experience for frontend you probably want a JavaScript framework like React or React native for mobile.

If you really want to use firebase and ios you might look at ios specific frameworks, Flutter, Swift, React Native. Imo the python frameworks are not good on mobile. Django might have some tools for mobile though, unsure on that one.",2025-04-30T18:51:24,"['id', 'recommend', 'fastapi', 'shiny', 'new', 'equivalent', 'flask', 'less', 'familiar', 'django', 'believe', 'used', 'full', 'stack', 'frontend', 'backend', 'experience', 'frontend', 'probably', 'want', 'javascript', 'framework', 'like', 'react', 'react', 'native', 'mobile', 'really', 'want', 'use', 'firebase', 'io', 'might', 'look', 'io', 'specific', 'framework', 'flutter', 'swift', 'react', 'native', 'imo', 'python', 'framework', 'good', 'mobile', 'django', 'might', 'tool', 'mobile', 'though', 'unsure', 'one']"
Python,"If someone’s choosing between Django, FastAPI, or Flask, I’d personally go with Django — especially for big monolithic apps. But even for smaller projects, it still holds up really well.

Once you get comfortable with how Django is structured — apps, models, views, serializers, class-based views, mixins — it really starts to feel powerful. And tools like Django Rest Framework or django-filter make a lot more sense once you understand the Django philosophy. They follow the same patterns, so if you get that, you can extend or build your own stuff cleanly — which is super helpful as the project grows.

One thing I really appreciate is how solid the ORM and migration system is. You don’t have to manually manage schema changes or deal with raw SQL unless you want to — it’s just smooth. Also, async support is maturing well in Django now, so you're not missing out on that front either.

The ecosystem is huge, the community is super helpful, and there are packages for pretty much anything. And if you like the FastAPI-style APIs (type hints, minimal boilerplate), check out Django Ninja — it gives you that clean style while staying within the Django world.",2025-04-30T19:34:40,"['someone’s', 'choosing', 'django', 'fastapi', 'flask', 'i’d', 'personally', 'go', 'django', '—', 'especially', 'big', 'monolithic', 'apps', 'even', 'smaller', 'project', 'still', 'hold', 'really', 'well', 'get', 'comfortable', 'django', 'structured', '—', 'apps', 'model', 'view', 'serializers', 'classbased', 'view', 'mixins', '—', 'really', 'start', 'feel', 'powerful', 'tool', 'like', 'django', 'rest', 'framework', 'djangofilter', 'make', 'lot', 'sense', 'understand', 'django', 'philosophy', 'follow', 'pattern', 'get', 'extend', 'build', 'stuff', 'cleanly', '—', 'super', 'helpful', 'project', 'grows', 'one', 'thing', 'really', 'appreciate', 'solid', 'orm', 'migration', 'system', 'don’t', 'manually', 'manage', 'schema', 'change', 'deal', 'raw', 'sql', 'unless', 'want', '—', 'it’s', 'smooth', 'also', 'async', 'support', 'maturing', 'well', 'django', 'youre', 'missing', 'front', 'either', 'ecosystem', 'huge', 'community', 'super', 'helpful', 'package', 'pretty', 'much', 'anything', 'like', 'fastapistyle', 'apis', 'type', 'hint', 'minimal', 'boilerplate', 'check', 'django', 'ninja', '—', 'give', 'clean', 'style', 'staying', 'within', 'django', 'world']"
Python,I am an android engineer. I learned python by starting with FASTAPI and now I have a backend setup pretty nice.,2025-04-30T20:36:05,"['android', 'engineer', 'learned', 'python', 'starting', 'fastapi', 'backend', 'setup', 'pretty', 'nice']"
Python,"I prefer Starlette, it’s fastapi but without forcing you into annotation hell and gives you flexibility to use msgspec instead of pydantic. there’s nothing wrong with pydantic but msgspec is a little lighter and doesn’t have a dependency on rust. 

I wouldn’t invest too much into any one framework though. If the goal is learning, learn how to build your own http server",2025-05-01T02:06:55,"['prefer', 'starlette', 'it’s', 'fastapi', 'without', 'forcing', 'annotation', 'hell', 'give', 'flexibility', 'use', 'msgspec', 'instead', 'pydantic', 'there’s', 'nothing', 'wrong', 'pydantic', 'msgspec', 'little', 'lighter', 'doesn’t', 'dependency', 'rust', 'wouldn’t', 'invest', 'much', 'one', 'framework', 'though', 'goal', 'learning', 'learn', 'build', 'http', 'server']"
Python,"if you're focused on ios i guess why hold on to python?

EDIT: this is from someone who would die for FastAPI in a heartbeat. My favorite framework hands down but that's me and my flow.",2025-05-01T02:13:24,"['youre', 'focused', 'io', 'guess', 'hold', 'python', 'edit', 'someone', 'would', 'die', 'fastapi', 'heartbeat', 'favorite', 'framework', 'hand', 'thats', 'flow']"
Python,"MicroPie is super easy to learn! Check out [https://patx.github.io/micropie](https://patx.github.io/micropie)

Its ASGI and is super simple. Check it out. I wrote and maintain it.

  
Flask is WSGI which we are somewhat transitioning away from (hence fastapi's (also asgi) newfound popularity)",2025-05-01T05:06:59,"['micropie', 'super', 'easy', 'learn', 'check', 'asgi', 'super', 'simple', 'check', 'wrote', 'maintain', 'flask', 'wsgi', 'somewhat', 'transitioning', 'away', 'hence', 'fastapis', 'also', 'asgi', 'newfound', 'popularity']"
Python,“Best”,2025-05-01T08:09:30,['“best”']
Python,"Fastapi allows you to apply hexagonal design very easily. I guess that Flask too. Django on the other hand is very coupled. The worst thing I don like is having your core entities tight to the framework. 

If the project is not big you can go for Django but in other cases my bet is Fastapi. It's a framework focused on one task and only one, rest API. Rest of the task you can use other focused libraries.

It has been a long time since I didn't use Django, do you still need DRF to decouple the frontend?",2025-05-01T08:24:14,"['fastapi', 'allows', 'apply', 'hexagonal', 'design', 'easily', 'guess', 'flask', 'django', 'hand', 'coupled', 'worst', 'thing', 'like', 'core', 'entity', 'tight', 'framework', 'project', 'big', 'go', 'django', 'case', 'bet', 'fastapi', 'framework', 'focused', 'one', 'task', 'one', 'rest', 'api', 'rest', 'task', 'use', 'focused', 'library', 'long', 'time', 'since', 'didnt', 'use', 'django', 'still', 'need', 'drf', 'decouple', 'frontend']"
Python,"**go for fastapi plus pydantic** \- I assume you just need API endpoints for your iOS app.

also consider firebase cloud functions or node.js as alternatives for your project.",2025-04-30T12:09:27,"['go', 'fastapi', 'plus', 'pydantic', 'assume', 'need', 'api', 'endpoint', 'io', 'app', 'also', 'consider', 'firebase', 'cloud', 'function', 'nodejs', 'alternative', 'project']"
Python,"It depends. If you need a bunch of CRUD endpoints (for your mobile app, native app, single-page app, etc), then FastAPI will be the perfect choice. It’s well-designed, well-documented, relatively fast, and has a huge community. Both sync and async paradigms are supported (but you should pick the one early). Learning curve is short, you may start your backend just after a few tutorials. On the other hand, if you need a fully functional web app (with multi-page frontend, styles, DB, etc.), then the better option will be Django or Flask. Django designed with the «batteries included» approach, Flask is more minimalistic.",2025-04-30T13:23:25,"['depends', 'need', 'bunch', 'crud', 'endpoint', 'mobile', 'app', 'native', 'app', 'singlepage', 'app', 'etc', 'fastapi', 'perfect', 'choice', 'it’s', 'welldesigned', 'welldocumented', 'relatively', 'fast', 'huge', 'community', 'sync', 'async', 'paradigm', 'supported', 'pick', 'one', 'early', 'learning', 'curve', 'short', 'may', 'start', 'backend', 'tutorial', 'hand', 'need', 'fully', 'functional', 'web', 'app', 'multipage', 'frontend', 'style', 'db', 'etc', 'better', 'option', 'django', 'flask', 'django', 'designed', '«batteries', 'included»', 'approach', 'flask', 'minimalistic']"
Python,"FastAPI. 
Django has too much abstraction and doesn’t allow using good practices like separation of concerns etc. Having to put business logic in serializers or models is awful.",2025-04-30T12:18:12,"['fastapi', 'django', 'much', 'abstraction', 'doesn’t', 'allow', 'using', 'good', 'practice', 'like', 'separation', 'concern', 'etc', 'put', 'business', 'logic', 'serializers', 'model', 'awful']"
Python,Fastapi,2025-04-30T10:52:23,['fastapi']
Python,Loved using fastapi,2025-04-30T11:38:46,"['loved', 'using', 'fastapi']"
Python,"In my experience, the FastAPI documentation is really good. Also, both Flask and FastAPI will use the \`firebase-admin\` and/or \`pyrebase\` libraries so the experience will be pretty similar on that side.",2025-04-30T11:39:11,"['experience', 'fastapi', 'documentation', 'really', 'good', 'also', 'flask', 'fastapi', 'use', 'firebaseadmin', 'andor', 'pyrebase', 'library', 'experience', 'pretty', 'similar', 'side']"
Python,Yes,2025-04-30T12:41:49,['yes']
Python,[deleted],2025-04-30T12:58:50,['deleted']
Python,"I usually decide by
Small poc or fire and forget code - flask, fastapi
Full featured web app with admin interface and orm support inbuilt, strict structural setup required - Django
High performance inbuilt async REST API, AI ML usecases - Fastapi",2025-04-30T13:44:19,"['usually', 'decide', 'small', 'poc', 'fire', 'forget', 'code', 'flask', 'fastapi', 'full', 'featured', 'web', 'app', 'admin', 'interface', 'orm', 'support', 'inbuilt', 'strict', 'structural', 'setup', 'required', 'django', 'high', 'performance', 'inbuilt', 'async', 'rest', 'api', 'ai', 'ml', 'usecases', 'fastapi']"
Python,"Honestly, FastAPI. It's great for writing a pure API, can integrate well with Firebase, and you get typing in the requests, which helps a lot",2025-04-30T12:01:54,"['honestly', 'fastapi', 'great', 'writing', 'pure', 'api', 'integrate', 'well', 'firebase', 'get', 'typing', 'request', 'help', 'lot']"
Python,"If you want to go fully API, I'd suggest FastAPI, since you can customize the whole application based on your preferences and it is easier. 

But if you're looking for a full stack solution, I'd either go with Flask or Django. 

Django gets you faster to the point, but Flask will make you understand those things better since you need to develop most of the stuff on your own.",2025-04-30T12:13:11,"['want', 'go', 'fully', 'api', 'id', 'suggest', 'fastapi', 'since', 'customize', 'whole', 'application', 'based', 'preference', 'easier', 'youre', 'looking', 'full', 'stack', 'solution', 'id', 'either', 'go', 'flask', 'django', 'django', 'get', 'faster', 'point', 'flask', 'make', 'understand', 'thing', 'better', 'since', 'need', 'develop', 'stuff']"
Python,"You might want to check out lihil, it has built in auth system that let you set up oauth compatible auth system within a few lines.",2025-04-30T10:40:17,"['might', 'want', 'check', 'lihil', 'built', 'auth', 'system', 'let', 'set', 'oauth', 'compatible', 'auth', 'system', 'within', 'line']"
Python,"Some tips:

- Separate your logic! Don’t put everything in one function, create seperate functions (or classes if you’re planning on extending your language) for getting the next token, deciding on what to do with the next token and actually executing instructions.

- If you want to extend your language: create seperate classes for tokenizing, parsing the programm (checking syntax etc.) and constructing an abstract syntax tree and the actual interpreter that just walks that abstract syntax tree, executing it in the process. 

If you want to take a look at a bigger Compiler Project, you can check out my Python to C++ Compiler pytocpp [here](https://www.github.com/b3d3vtvng/pytocpp) 
Also hit me up if you need any advice.

Edit: Spelling",2025-04-25T16:39:18,"['tip', 'separate', 'logic', 'don’t', 'put', 'everything', 'one', 'function', 'create', 'seperate', 'function', 'class', 'you’re', 'planning', 'extending', 'language', 'getting', 'next', 'token', 'deciding', 'next', 'token', 'actually', 'executing', 'instruction', 'want', 'extend', 'language', 'create', 'seperate', 'class', 'tokenizing', 'parsing', 'programm', 'checking', 'syntax', 'etc', 'constructing', 'abstract', 'syntax', 'tree', 'actual', 'interpreter', 'walk', 'abstract', 'syntax', 'tree', 'executing', 'process', 'want', 'take', 'look', 'bigger', 'compiler', 'project', 'check', 'python', 'c', 'compiler', 'pytocpp', 'also', 'hit', 'need', 'advice', 'edit', 'spelling']"
Python,Why is it called Pear?,2025-04-25T18:52:50,"['called', 'pear']"
Python,"Not so much a programming language, moreso a turing machine",2025-04-25T17:00:06,"['much', 'programming', 'language', 'moreso', 'turing', 'machine']"
Python,I’d recommend doing a chip8 emulator as the next step to this r/emudev,2025-04-25T19:14:00,"['i’d', 'recommend', 'chip8', 'emulator', 'next', 'step', 'remudev']"
Python,Have you considered using Pear to write a new programming language? You could call it 'Pie.',2025-04-26T17:09:06,"['considered', 'using', 'pear', 'write', 'new', 'programming', 'language', 'could', 'call', 'pie']"
Python,"Shebangs ! That way you can just run 

./myscript.pr",2025-04-25T17:54:15,"['shebang', 'way', 'run', 'myscriptpr']"
Python,Perhaps try to cythonize it for performance.,2025-04-26T08:09:01,"['perhaps', 'try', 'cythonize', 'performance']"
Python,"Oh, thank you very much. I am looking for a simple project to learn. Yours looks interesting. Can i help you?",2025-04-26T08:29:57,"['oh', 'thank', 'much', 'looking', 'simple', 'project', 'learn', 'look', 'interesting', 'help']"
Python,"I think you should try to solve some problems with your language to find it's limitations, and also flesh out the library. What are you trying to learn here? I would encourage you to turn this into a compiler as I think you would learn a lot from it. Also you could add a bit more syntax (infix operations for example) and learn more about parsers.",2025-04-27T01:02:45,"['think', 'try', 'solve', 'problem', 'language', 'find', 'limitation', 'also', 'flesh', 'library', 'trying', 'learn', 'would', 'encourage', 'turn', 'compiler', 'think', 'would', 'learn', 'lot', 'also', 'could', 'add', 'bit', 'syntax', 'infix', 'operation', 'example', 'learn', 'parser']"
Python,[ R vs Python in Machine Learning](https://posts.gle/d3WupA),2025-04-28T09:38:59,"['r', 'v', 'python', 'machine', 'learning']"
Python,"What is the exact purpose or benefit over using an interpreted language like python directly?

Nice side project but it doesn’t seem to have any real world use case or benefit.",2025-04-25T16:15:59,"['exact', 'purpose', 'benefit', 'using', 'interpreted', 'language', 'like', 'python', 'directly', 'nice', 'side', 'project', 'doesn’t', 'seem', 'real', 'world', 'use', 'case', 'benefit']"
Python,subbing.,2025-04-26T04:53:42,['subbing']
Python,whyd you choose python,2025-04-27T18:52:16,"['whyd', 'choose', 'python']"
Python,Benchmarks?,2025-04-29T00:30:09,['benchmark']
Python,Very nice,2025-04-28T20:24:45,['nice']
Python,"Tried it myself, this is very useful",2025-04-28T21:28:42,"['tried', 'useful']"
Python,"Benchmarks vs Numba, please.",2025-04-29T00:48:35,"['benchmark', 'v', 'numba', 'please']"
Python,How does it compare to Pypy (the One True Python implementation)?,2025-04-29T04:20:52,"['compare', 'pypy', 'one', 'true', 'python', 'implementation']"
Python,"So I lose the granularity and performance of Cython for something that massively increases the latency of my function, and it also shits all over my filesystem with its cache, simply because I didn’t want to use my IDE settings to hide the compiled binaries? Fastest way to get my PR rejected.",2025-04-30T19:27:02,"['lose', 'granularity', 'performance', 'cython', 'something', 'massively', 'increase', 'latency', 'function', 'also', 'shit', 'filesystem', 'cache', 'simply', 'didn’t', 'want', 'use', 'ide', 'setting', 'hide', 'compiled', 'binary', 'fastest', 'way', 'get', 'pr', 'rejected']"
Python,Thanks for what you do! I use selenium base for various home automation integrations that aren't officially supported.,2025-04-25T01:31:44,"['thanks', 'use', 'selenium', 'base', 'various', 'home', 'automation', 'integration', 'arent', 'officially', 'supported']"
Python,"Have you considered that there is a reason why CAPTCHAs exist in the first place and that you're now enabling those reasons to do what people wanted to prevent?


E.g. Fake reviews on cloud flare, tons of unqualified applicants in indeed, manipulation of search popularity in google...",2025-04-24T16:37:49,"['considered', 'reason', 'captchas', 'exist', 'first', 'place', 'youre', 'enabling', 'reason', 'people', 'wanted', 'prevent', 'eg', 'fake', 'review', 'cloud', 'flare', 'ton', 'unqualified', 'applicant', 'indeed', 'manipulation', 'search', 'popularity', 'google']"
Python,If you research battle tested backend frameworks in other languages you'll see something like this is quite rare. There's a reason for that. All this global state and magic make it harder to reason about the program. Backends tend to prefer stability,2025-04-26T15:58:51,"['research', 'battle', 'tested', 'backend', 'framework', 'language', 'youll', 'see', 'something', 'like', 'quite', 'rare', 'there', 'reason', 'global', 'state', 'magic', 'make', 'harder', 'reason', 'program', 'backends', 'tend', 'prefer', 'stability']"
Python,I'd love to use it if the overhead is small enough. Is it fully implemented in Python? How much longer can I expect 1m updates to take in the simplest scenario?,2025-04-26T15:47:56,"['id', 'love', 'use', 'overhead', 'small', 'enough', 'fully', 'implemented', 'python', 'much', 'longer', 'expect', '1m', 'update', 'take', 'simplest', 'scenario']"
Python,"Cool project. Can you please give me the dumbed down explanation of what this is doing, or what it’s used for? I can’t really make sense of it. Iiuc, it seems to be a way of implementing an observer pattern?",2025-04-26T22:22:35,"['cool', 'project', 'please', 'give', 'dumbed', 'explanation', 'it’s', 'used', 'can’t', 'really', 'make', 'sense', 'iiuc', 'seems', 'way', 'implementing', 'observer', 'pattern']"
Python,What use cases are you targeting with this library?,2025-04-26T15:37:56,"['use', 'case', 'targeting', 'library']"
Python,As a manager if someone brings this as an alternative to the current systems he will be fired,2025-04-26T13:52:54,"['manager', 'someone', 'brings', 'alternative', 'current', 'system', 'fired']"
Python,"Well … no.
You’re missing docstrings and you have a lower case “signal” function which appears to do nothing but create a Signal class.

The concept isn’t that difficult… I’ve done it once or twice… and it’s not following Python conventions.",2025-04-26T17:52:37,"['well', '…', 'you’re', 'missing', 'docstrings', 'lower', 'case', '“signal”', 'function', 'appears', 'nothing', 'create', 'signal', 'class', 'concept', 'isn’t', 'difficult…', 'i’ve', 'done', 'twice…', 'it’s', 'following', 'python', 'convention']"
Python,"There's no need for the additional literal type. You can just set the type in your Pydantic model to `Color`. You might need a bit of serialization logic, but Pydantic is pretty slick when it comes to handling enums.",2025-04-25T03:03:27,"['there', 'need', 'additional', 'literal', 'type', 'set', 'type', 'pydantic', 'model', 'color', 'might', 'need', 'bit', 'serialization', 'logic', 'pydantic', 'pretty', 'slick', 'come', 'handling', 'enums']"
Python,"As other commenter said, Enums have built in pydantic support. Also, subclass StrEnum instead of str & enum",2025-04-25T03:36:45,"['commenter', 'said', 'enums', 'built', 'pydantic', 'support', 'also', 'subclass', 'strenum', 'instead', 'str', 'enum']"
Python,"I have missed exactly this feature (in a non-Pydantic-setting) recently. I ended up giving up, and using a literal type instead of enums (can still extract a list of all variants via `typing.get_args()`).


However, I don't think there's substantial interest in defining more and more special forms. On the other hand, there's no systematic way to solve this because Python type expressions must also be valid runtime objects. C++ can have decltype and TypeScript can have projections due to having a compilation step (C++) or due to types having no runtime representation (TS). Python could get a good enough approximation by adding a nested type like `Color.Values`, except that this wouldn't work on unions like `(Color.RED | Color.BLUE).Values`.


So a special form like `EnumValues[T]` is indeed the only possible solution, but that's a lot of complexity for a fairly niche feature.",2025-04-25T06:59:08,"['missed', 'exactly', 'feature', 'nonpydanticsetting', 'recently', 'ended', 'giving', 'using', 'literal', 'type', 'instead', 'enums', 'still', 'extract', 'list', 'variant', 'via', 'typinggetargs', 'however', 'dont', 'think', 'there', 'substantial', 'interest', 'defining', 'special', 'form', 'hand', 'there', 'systematic', 'way', 'solve', 'python', 'type', 'expression', 'must', 'also', 'valid', 'runtime', 'object', 'c', 'decltype', 'typescript', 'projection', 'due', 'compilation', 'step', 'c', 'due', 'type', 'runtime', 'representation', 't', 'python', 'could', 'get', 'good', 'enough', 'approximation', 'adding', 'nested', 'type', 'like', 'colorvalues', 'except', 'wouldnt', 'work', 'union', 'like', 'colorred', 'colorbluevalues', 'special', 'form', 'like', 'enumvaluest', 'indeed', 'possible', 'solution', 'thats', 'lot', 'complexity', 'fairly', 'niche', 'feature']"
Python,"The API use case highlights a subtle problem: What's actually checking that these strings actually have one of these values? Static types are ignored at runtime, and if you've just received a value over the wire, you don't know it's one of these values. You're going to need some kind of runtime logic to validate this, and it might as well be the logic that turns it into an enum (which Pydantic supports reasonably well).


I suspect that if you want this, then you probably have a layering problem.",2025-04-25T10:07:17,"['api', 'use', 'case', 'highlight', 'subtle', 'problem', 'whats', 'actually', 'checking', 'string', 'actually', 'one', 'value', 'static', 'type', 'ignored', 'runtime', 'youve', 'received', 'value', 'wire', 'dont', 'know', 'one', 'value', 'youre', 'going', 'need', 'kind', 'runtime', 'logic', 'validate', 'might', 'well', 'logic', 'turn', 'enum', 'pydantic', 'support', 'reasonably', 'well', 'suspect', 'want', 'probably', 'layering', 'problem']"
Python,Just use the enum members directly instead of the string values,2025-04-25T08:00:58,"['use', 'enum', 'member', 'directly', 'instead', 'string', 'value']"
Python,Could you use StrEnum to achieve this?,2025-04-25T03:06:04,"['could', 'use', 'strenum', 'achieve']"
Python,Pydantic also supports colors using the extra types package https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/,2025-04-25T03:56:49,"['pydantic', 'also', 'support', 'color', 'using', 'extra', 'type', 'package']"
