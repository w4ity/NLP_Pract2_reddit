[
  {
    "flair": "News",
    "title": "Pip 25.1 is here - install dependency groups and output lock files!",
    "author": "zurtex",
    "date": "2025-04-26T19:39:11",
    "score": 237,
    "description": "This weekend pip 25.1 has been released, the big new features are that you can now install a dependency group, e.g. `pip install --group test`, and there is experimental support for outputting a PEP 751 lock file, e.g. `pip lock requests -o -`.\n\nThere is a larger changelog than normal but but one of our maintainers has wrote up an excellent highlights blog post: https://ichard26.github.io/blog/2025/04/whats-new-in-pip-25.1/\n\nOtherwise here is the full changelog: https://github.com/pypa/pip/blob/main/NEWS.rst#251-2025-04-26",
    "comments": [
      {
        "user": "condalf97",
        "comment": "I am more excited for installing dependency groups than someone should really be.",
        "score": 60,
        "date": "2025-04-26T19:58:42",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.015,
          "neutral": 0.054,
          "positive": 0.931
        },
        "emotion": "joy",
        "emotion_probs": {
          "anger": 0.008,
          "disgust": 0.002,
          "fear": 0.004,
          "joy": 0.6,
          "neutral": 0.374,
          "sadness": 0.003,
          "surprise": 0.01
        }
      },
      {
        "user": "pacific_plywood",
        "comment": "Sorry if this is a dumb question — what’s the difference between this dependency groups feature and  ‘pip install myproject[tests,dev]’",
        "score": 19,
        "date": "2025-04-26T23:35:58",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.413,
          "neutral": 0.531,
          "positive": 0.056
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.012,
          "fear": 0.002,
          "joy": 0.001,
          "neutral": 0.894,
          "sadness": 0.008,
          "surprise": 0.077
        }
      },
      {
        "user": "Hallsville3",
        "comment": "Excited about `pip index versions --json`!",
        "score": 7,
        "date": "2025-04-26T20:48:51",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.001,
          "neutral": 0.022,
          "positive": 0.977
        },
        "emotion": "joy",
        "emotion_probs": {
          "anger": 0.015,
          "disgust": 0.001,
          "fear": 0.01,
          "joy": 0.431,
          "neutral": 0.272,
          "sadness": 0.0,
          "surprise": 0.27
        }
      },
      {
        "user": "chadrik",
        "comment": "All of my hopes and dreams are invested in uv now.",
        "score": 18,
        "date": "2025-04-26T23:45:37",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.011,
          "neutral": 0.259,
          "positive": 0.73
        },
        "emotion": "joy",
        "emotion_probs": {
          "anger": 0.009,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.532,
          "neutral": 0.448,
          "sadness": 0.008,
          "surprise": 0.001
        }
      },
      {
        "user": "case_O_The_Mondays",
        "comment": "Kind of cool to see the Home Assistant reference :)\n\nWhen I saw that progress bar, I thought “I’ve seen that before.” Sure enough, they’re using rich to display it. \n\nI’d like to make a joke about installing uv looking so much better now, but maybe there’s a chance that pip will fold uv in, and adopt it.",
        "score": 6,
        "date": "2025-04-26T21:51:51",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.007,
          "neutral": 0.064,
          "positive": 0.929
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.003,
          "fear": 0.002,
          "joy": 0.113,
          "neutral": 0.868,
          "sadness": 0.001,
          "surprise": 0.007
        }
      },
      {
        "user": "AndydeCleyre",
        "comment": "Is it possible to specify required dependency groups for an item within a requirements.txt file?",
        "score": 2,
        "date": "2025-04-26T23:05:41",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.082,
          "neutral": 0.885,
          "positive": 0.032
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.984,
          "sadness": 0.001,
          "surprise": 0.009
        }
      },
      {
        "user": "jpgoldberg",
        "comment": "I’ve only recently started using dependency groups (through uv). They are so much better than using multiple requirements files, but I still haven’t gotten good at really using them and organizing them well. But I am confident that I will.",
        "score": 1,
        "date": "2025-04-26T23:36:09",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.029,
          "neutral": 0.137,
          "positive": 0.834
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.002,
          "joy": 0.089,
          "neutral": 0.901,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "Prior_Boat6489",
        "comment": "pip is the new Internet Explorer. Just pip install uv",
        "score": -14,
        "date": "2025-04-26T20:49:32",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.07,
          "neutral": 0.584,
          "positive": 0.346
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.006,
          "neutral": 0.986,
          "sadness": 0.001,
          "surprise": 0.005
        }
      },
      {
        "user": "oulipo",
        "comment": "What's the use-case of pip now that there is uv? are there features not yet reimplemented by uv?",
        "score": -1,
        "date": "2025-04-27T06:55:45",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.108,
          "neutral": 0.854,
          "positive": 0.038
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.008,
          "fear": 0.002,
          "joy": 0.001,
          "neutral": 0.779,
          "sadness": 0.003,
          "surprise": 0.202
        }
      }
    ],
    "resumen_mt5": "Welcome to pip 25.1!"
  },
  {
    "flair": "Discussion",
    "title": "What are your experiences with using Cython or native code (C/Rust) to speed up Python?",
    "author": "Independent_Check_62",
    "date": "2025-04-25T12:47:36",
    "score": 179,
    "description": "I'm looking for concrete examples of where you've used tools like Cython, C extensions, or Rust (e.g., pyo3) to improve performance in Python code.\n\n* What was the specific performance issue or bottleneck?\n* What tool did you choose and why?\n* What kind of speedup did you observe?\n* How was the integration process—setup, debugging, maintenance?\n* In hindsight, would you do it the same way again?\n\nInterested in actual experiences—what worked, what didn’t, and what trade-offs you encountered.",
    "comments": [
      {
        "user": "rikus671",
        "comment": "numba.njit for a numpy array transformation i did not know how to do using the built-in operations. Was about 200x faster (it went from the bottleneck to negligeable).\n\nnumba.njit is VERY good for these short, single function, math-heavy compiles. No need to change anything in your pipeline, debugging is okay, you can just disable the decorator and go back to python for testing stuff.\n\nFor anything small-scale its my go-to.",
        "score": 120,
        "date": "2025-04-25T12:59:27",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.015,
          "neutral": 0.097,
          "positive": 0.888
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.017,
          "neutral": 0.977,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "nonamepew",
        "comment": "This is pretty much all I do at my job. I have extensively used Cython, Numba, C/C++ extensions, llvmlite.\n\nIf used correctly, all of them will achieve same performance. IMO, it is more about ease of use.\n\nNumba works very well when the operation you want to speed-up is rather trivial.\n\nFor a little more complex things, Cython is good. Cython sometimes makes the job harder instead. For eg., templated logic is hard in Cython. Fused type support is also lackluster IMO.\n\nC/C++ extensions basically gives you super powers but they are a pain in the ass to write. Especially, dealing with CPython API is pain. Boilerplate code also increases rather easily with pure C/C++ extensions.\n\nFor most task, I have found C/C++ code wrapped up in Cython works best.\n\nI have used llvmlite, but that is reserved for most performance sensitive code, where we may want to JIT compile some operation for a specific type (or a combination of types in real usage).",
        "score": 53,
        "date": "2025-04-25T13:47:00",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.105,
          "neutral": 0.356,
          "positive": 0.539
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.017,
          "fear": 0.0,
          "joy": 0.004,
          "neutral": 0.964,
          "sadness": 0.009,
          "surprise": 0.001
        }
      },
      {
        "user": "Jannik2099",
        "comment": "I've written some bindings for my C++ library with nanobind.\n\nIntegration was trivial as I automated binding of classes with roughly 150 lines of code.\n\nI don't have a performance comparison as this is for a CPU bound problem, so I never considered implementing it in Python to begin with.",
        "score": 16,
        "date": "2025-04-25T13:10:02",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.298,
          "neutral": 0.516,
          "positive": 0.186
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.002,
          "fear": 0.0,
          "joy": 0.003,
          "neutral": 0.989,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "Crazy_Anywhere_4572",
        "comment": "I am writing a N-body gravity simulation library. It was written in python but overtime the whole code base is rewritten in c with a python wrapper. The speed improvement from vectorised NumPy to C is 50x to 100x.\n\nIt is not particularly difficult to maintain since I am just writing in plain C. In fact, my library can even be used without python, but having a python wrapper is quite nice. All I need to do in Python is to load the c dynamic-link library with ctypes.cdll.",
        "score": 30,
        "date": "2025-04-25T13:12:33",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.008,
          "neutral": 0.085,
          "positive": 0.907
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.0,
          "joy": 0.014,
          "neutral": 0.979,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "SV-97",
        "comment": "I implemented a bunch of numerics code in Rust (broadly speaking mathematical optimization, computational geometry, signal processing). The issues in python were performance on the one hand (think low level \"number crunching\"), but also correctness (for example with a quite intricate dynamic program with plenty of places to \"go slightly wrong\").\n\nThe project I'm currently working on is basically \"pure\" mathematical programming around a problem involving order statistics etc. for very large datasets. The base algorithms needed to implement that are either not available in python or incur full copies of the full dataset that have to (and can) be avoided. Rust also enables the low level control over memory needed for such problems.\n\n>What tool did you choose and why?\n\nRust, because it's a great language with great tooling. C has the same correctness problems as Python would have and writing and integrating C extensions kind of sucks, lol no to fortran etc., and I don't know Cython (and don't think it'd be a great experience for me personally).\n\nSpecifically I use [maturin](https://github.com/PyO3/maturin) with [pyo3](https://github.com/PyO3/pyo3), although I'd try using [uniffi](https://github.com/mozilla/uniffi-rs) for my next project (because I don't actually need a complicated API for my library).\n\n>What kind of speedup did you observe?\n\nIt doesn't really make sense to speak of a speedup for me personally, since the kind of stuff I write currently tends to go from \"completely infeasible\" to \"can be done\". \n\n>How was the integration process—setup, debugging, maintenance?\n\nsetup is trivial, maintenance depends on your API surface, what exactly you want to do, what you change, what sort of dependencies you have etc. Debugging also depends on how you do things. I tend to implement everything in rust and then have the python API be a \"consumer\" of the rust API, which means that debugging is just debugging a rust project.\n\n>In hindsight, would you do it the same way again? \n\nYes, in fact I have done it this way for quite a few projects at this point and love it.",
        "score": 27,
        "date": "2025-04-25T13:27:56",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.299,
          "neutral": 0.471,
          "positive": 0.23
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.007,
          "disgust": 0.006,
          "fear": 0.002,
          "joy": 0.001,
          "neutral": 0.981,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "-lq_pl-",
        "comment": "I maintain several OSS packages that use a mix of C++ and Python or Numba. Python bindings for C++ code are handwritten with pybind11. Here are my experiences:\n\nIf you can, use Numba. It is as fast as well-written C++ or Rust code. Behind the scenes your code is compiled into optimized machine code with LLVM. Maintenance is so much easier, because all your code is still Python and you don't have to make binary wheels during deployment (this is a huge hassle to set up).\n\nIf Numba doesn't work for you (your program's runtime is not dominated by isolated hot code paths), use Rust or C++, don't write code in C. In Rust or C++, you'll have automated life-time management and type conversion (from native Python to native compiled language and vice versa), which in C, you have to code yourself, which is error prone, brittle, and requires large amounts of boilerplate.\n\nA note on automatic binding generators. There are tools which claim that they can generate the bindings for you automatically. You can use these as a starting point, but they cannot do the job properly unless you have a trivial code base. Tools cannot guess how object ownership should be handled performantly case-by-case (often you want to avoid copying data, so you want to share ownership intelligently between the Python side and the compiled side), and the interfaces they generate won't be pythonic. If you care about performance and API design, you want to have full control over the language boundary, so you should write the bindings manually.\n\nNow if you want to deploy your package to users, you need to set up your project so that the code is compiled on a \\`pip install\\`. This means you have to integrate with a foreign build system like CMake. Once you figured that out, you can then just ship a sdist package, but that's bad, people need the right compiler on their local machine to use your package, and installing may take a lot of time. The user-friendly way is to generate the wheels for them using a CI/CD pipeline. Doing that correctly for Windows, Linux, and MacOS is a hard problem, fortunately, the package cibuildwheel exists, which greatly simplifies the process.\n\nSome things I'd advice against:\n\n\\- Cython: clunky, because you need to learn a domain-specific language that is not well documented, only works well with C code (but see issues with C code), C++ support is bad\n\n\\- Swig: You don't want to pull in a separate parsing program for your language (only works well for C, not C++ last time I checked - which was a few years ago).\n\nUpdate: I see that nanobind is the successor to pybind11 and written by the same author, so new projects should use nanobind instead of pybind11.",
        "score": 11,
        "date": "2025-04-25T15:02:22",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.332,
          "neutral": 0.481,
          "positive": 0.186
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.004,
          "fear": 0.001,
          "joy": 0.003,
          "neutral": 0.988,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "PersonalityIll9476",
        "comment": "I've done a bit of this. From the hobby side of things, I worked on a Python game engine. Bits of code like the collision detection subsystem are performance critical and must run on CPU every game loop. It's difficult to write those algorithms with simple vectorized functions so it made sense to do it in C. Used Cython to create the Python bindings. Data inputs were numpy arrays. The way you interoperate is to use numpy headers to directly access memory pointers from numpy array Python objects. Trying to use Cython's various built-in methods for fetching that pointer were all way too slow, for whatever reason. In a game loop, you really need things to be happening much faster than 1e-5 seconds. The most safety checking I did was checking array flags (is it c_contiguous? Etc).\n\nAlso required a few external C libs and loaded those with ctypes. IMO, ctypes is a god send if you need c libraries and don't particularly care about speed. For a game engine that means these calls aren't happening every game loop (every frame). So a huge amount of supporting code could potentially be ctypes imports.\n\nThat's not the only project where I've used those tools, just the most recent.",
        "score": 7,
        "date": "2025-04-25T13:28:58",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.414,
          "neutral": 0.46,
          "positive": 0.127
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.991,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "Schmittfried",
        "comment": "I used Cython in a scientific data processing pipeline where the code had to be comprehensible-ish to my data scientist coworkers.\n\nThe bottleneck was a huge runtime/memory overhead when I tried to refactor some components for parsing genomic data. It was a huge mess, but when I tried to replace tuples, dozens of lookup tables and stringly typed everything into well-defined dataclasses the performance was unacceptable.\n\nSo I considered native code, but that would have been a huge maintenance burden and made me a single point of failure. So I decided to use Cython in its pure Python mode and separated the parsing logic (and more importantly the data classes) into its own module.\n\nI picked a rather self-contained minor parsing component as a proof of concept first. It was IO-bound and already mostly using native builtins. I still increased runtime performance twofold and memory footprint fivefold while making the calling code much more readable, which was actually my only goal (I would have accepted similar performance characteristics).\n\nI tried to optimize it further because I thought it was still creating Python overhead unnecessarily. I would have loved to return byte strings from a shared memory buffer but unfortunately that’s not how Python‘s byte type works, so I had to accept that Python would still create separate byte objects with copies of the original content for some properties.\n\nWhich is to say: Beware of the fundamental compromises a native module will bring. The best use case is something that works completely autonomously and can just return the final result to the Python code, like numpy. Similarly, the most efficient data structures are those that never have to leave your native code. As soon as you have a back and forth between Python and native code you will incur runtime overhead and create Python objects with all their header overhead. Depending on your code (think of a tight loop producing many small objects) that might be a non-starter or perform even worse than pure Python. But to be fair, Cython does have a simple way to keep a fixed-size static list of pre-allocated objects of your structure to reuse them for temporary objects. Doesn’t help when you want to collect them into a list though.\n\n>How was the integration process—setup, debugging, maintenance?\n\nIt was expectedly less streamlined than pure Python. The build process became more complicated. Now there is two compile steps that weren’t necessary before. Testing also requires some extra setup to get correct coverage information and suddenly you will have build artifacts all over your code base (for compiled modules) that you want to get rid of for clean builds or debugging. Otherwise you can easily look at a piece of code while the code being executed from the compiled binary is actually completely different (it’s .pyc files but worse). Debugging itself was fine with PyCharm Professional. I actually don’t remember if I stepped into native code though.\n\nDespite tooling support for Cython you can expect some hiccups with linters and IDEs, at least with the pure Python mode, which is less supported (things will be detected as missing even though the Cython module exports them, cimports in particular).\n\n>In hindsight, would you do it the same way again?\n\nFor that module, definitely no. I still see it as the only option to make the rest of the code cleaner while keeping the performance up, but on the other hand it will never be fully maintainable by my non-engineer colleagues beyond minor tweaks, so I’m not sure it’s worth it, especially given the more complicated setup and more things that can go wrong with nobody to troubleshoot them but me. I remember setuptools and poetry causing some problems initially.\n\nSome difficulties were certainly my own fault. Cython’s pure Python mode allows a subset of its features to be used even without compiling (they’re just plain Python then, without the speedup). My goal was to achieve full Python compatibility so that the difference between compiling and running as is would be seamless. It made the setup much more complicated though, because now your tooling/scripts have to account for two modes of building/testing/running the code.\n\nLong story short: Think twice before using it and consider it only if you have buy-in. Everyone (or more than one person) working on the codebase should be willing to dig into Cython and step through its internals if necessary, because there aren’t that many (up-to-date) online resources to rely on.",
        "score": 6,
        "date": "2025-04-25T15:34:32",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.399,
          "neutral": 0.435,
          "positive": 0.166
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.016,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.968,
          "sadness": 0.005,
          "surprise": 0.002
        }
      },
      {
        "user": "jabrodo",
        "comment": "My specific use case is in scientific computing. I'm a PhD student doing research in algorithms, namely particle filters (those being the most memory-intensive). I run many repetitions of simulations.\n\nOn the Python side I've used both Numba and MyPyC. Cython is a complete non-starter for me. If I'm working in Python, I want to be working in Python, and not in some pseudo-Python language. My usual performance benchmark is a naive recursive Fibonacci sequence, just something dumb and basic and that I know I can force to take a human-discernible amount of time. Numba with array computation, and MyPyC with type annotation achieves performance on-par with native compiled C/C++/Rust.\n\nThe issue I had with MyPyC is that it *only* works on native Python code. It's a really great idea and I think if they can get it to the point where it works with extension libraries also written in Python (even better if it can also work with libraries written in C like NumPy) it will make Python pretty damn unbeatable as you'll be able to test in interpreted mode and deploy in compiled. Until then, the strength of Python is the ecosystem, not the standard library, so that option was out.\n\nNumba on the other hand is pretty great. It works well with NumPy and seeing as most scientific/computation Python libraries are based on NumPy, has a good ecosystem support. I find that Numba is best used for when everything else is in Python, save for this one loop/function call that is bottle-necking your code, and that code can be re-written using NumPy arrays. Better yet if it can be vectorized. Even jitting a dumb for loop of array calculations should get you a performance bump.\n\nThe problems with Numba are two fold: first it throws weird bugs and is really difficult to debug in my opinion; and second, for some reason jitted modules can't talk to each other. For instance: if I have module foo with jitted function bar, and I want to bar from a jitted function in another module it doesn't work. At least, I haven't been able to get it working. This kind of echos the problem of MyPyC. The strength of Python is the ecosystem, and Numba seemingly forced me into either adopting a third party library wholesale, and shoe-horning my functionality in somehow with whatever bottlenecks that produced, or alternatively building the entire library with my added functionality myself.\n\nThe specific bottleneck for me was looping over a set of calculations that I didn't want to vectorize. I had some reused functionality that was consistent across three different use cases that I didn't want to have to build and test for each (Particle filter, UKF/EKF) which vectorizing for the particle filter would have forced me to do. As such the solution was to move to writing an extension module so that I could take advantage of compiled speed even if it meant writing naive un-optimized libraries as compilation (and compiler optimization) would still be a significant boost to native Python.\n\nFrankly, I've found that using pybind11/nanobind for C++ or maturin and pyo3 for Rust are basically the same. The style is the same. The structure is the same. I find that matruin and pyo3 is a more streamlined experience and that Rust, in general, is just a much better experience than C++, but use whichever. Personally I prefer Rust. Memory safety is great and all, but the tooling is absolutely superb and I find that I like Rust's syntax more than C++. Rust feels like Python and C++ had a baby and unlearned all the pre-C++11 problems. Either way, this is the Python sub so it doesn't matter too much which compiled language you use. You'll still see a benefit and Python's garbage collector should handle the memory safety. If you haven't taken a look at it check out The Scientific Python Development Guide to [Packaging Compiled Projects](https://learn.scientific-python.org/development/guides/packaging-compiled/).\n\nThat said... committing to re-writing the bottle-necked backend in a compiled language made me realize that I really should just be doing the entire backend algorithm in Rust. So while not necessarily the question you were asking, what I've found is that if I'm getting to the point where I *really need* compiled performance, in all likelihood  that means it is time to learn how to use a compiled language, even if it is just to write simple naive implementations, and use Python instead for your data pre- and post-processing. Bindings are pretty solid, and I plan on writing some for my code, but there is still some performance overhead with the interpreter, GIL (multiprocessing only gets you so far), and Python's garbage collection.",
        "score": 4,
        "date": "2025-04-25T16:03:38",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.095,
          "neutral": 0.31,
          "positive": 0.594
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.006,
          "fear": 0.001,
          "joy": 0.006,
          "neutral": 0.977,
          "sadness": 0.004,
          "surprise": 0.001
        }
      },
      {
        "user": "baekalfen",
        "comment": "I sped up PyBoy with Cython and have used it several other places with good success. The speed up is in the x200-300 compared to CPython. But you’re probably unlikely to find such a good use case.\nFor debugging I use LLDB as well as CPython and PyPy. It’s usually easiest if the error is also present in the interpreter. But otherwise you know it’s a type issue.\n\nhttps://github.com/Baekalfen/PyBoy",
        "score": 4,
        "date": "2025-04-25T17:04:48",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.087,
          "neutral": 0.366,
          "positive": 0.547
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.001,
          "neutral": 0.991,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "L_e_on_",
        "comment": "I’m into reverse engineering and built a small library for code injection, virtual memory allocation, and simple memory management in target processes. Performance was important, especially for multithreaded AOB scans without the GIL.\n\nPython wasn’t ideal, dynamic typing and CPython’s speed are both issues, especially when scanning a process memory. So I wrote the core in C and Cython.\n\nSetup was a bit annoying and packaging was even more painful (mainly Python’s fault). But prange for multithreading was a nice, and I liked how Cython let me keep pure C code separate from hybrid C/Python parts. Much cleaner and faster than using ctypes to wrap, and none of the code used GIL.",
        "score": 3,
        "date": "2025-04-25T13:18:51",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.24,
          "neutral": 0.374,
          "positive": 0.386
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.01,
          "fear": 0.001,
          "joy": 0.004,
          "neutral": 0.971,
          "sadness": 0.009,
          "surprise": 0.001
        }
      },
      {
        "user": "superkoning",
        "comment": "Not me, but a very clever person built sabctools [https://github.com/sabnzbd/sabctools](https://github.com/sabnzbd/sabctools) : \"yEnc decoding and encoding using SIMD routines\" and \"CRC32 calculations\"\n\nSpeed improvements were 10-100x or so compared to plain C (wihout SIMD). And plain python ... almost unusable.",
        "score": 3,
        "date": "2025-04-25T14:00:59",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.129,
          "neutral": 0.382,
          "positive": 0.489
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.004,
          "fear": 0.0,
          "joy": 0.022,
          "neutral": 0.965,
          "sadness": 0.003,
          "surprise": 0.002
        }
      },
      {
        "user": "guyfrom7up",
        "comment": "I made [Tamp](https://github.com/BrianPugh/tamp), low-memory lossless compression library that was originally targetting micropython. So naturally, I prototyped it in vanilla cpython. Once I saw that general compression ratios were good, I then reimplemented it in C so that I could also use it without micropython on any microcontroller. I used Cython to have a fast python-compatible implementation, as well as to unit test the C parts of the code (I'd much rather write unit tests in python rather than C).\n\nIn this library, the C/Cython compression is about 6.7x faster, while decompression 535x faster. The compression isn't much faster because the main compression loop, finding the longest substring match in a buffer, is already implemented fairly efficiently in python via `str.index`.\n\n  \nCython has a bit of a learning curve, but their docs are actually quite comprehensive. I distilled my learnings into [my python template](https://github.com/BrianPugh/python-template), which has Cython working with Poetry and CI to build binaries for all python versions and architectures. I would definitely use Cython again for this purpose (creating a pythonic interface to C code). Given that the code within Cython should be minimal/simple/short/self-contained, things like ChatGPT work very well for helping!",
        "score": 3,
        "date": "2025-04-25T14:36:47",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.019,
          "neutral": 0.227,
          "positive": 0.754
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.014,
          "disgust": 0.002,
          "fear": 0.002,
          "joy": 0.013,
          "neutral": 0.967,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "not_a_novel_account",
        "comment": "My open source Python extensions: [velocem](https://github.com/nickelpro/velocem), [nanoroute](https://nanoroute.dev/)\n\n* Latency in general, everything is faster in native code\n\n* C++ and the CPython API\n\n* Between 30x and 1000x, depending on what metric you measure\n\n* It's normal C++ development for the most part\n\n* Yes, I think most Python should be setting up fast extension-based code to do its job and then getting out of the way.",
        "score": 3,
        "date": "2025-04-25T21:31:35",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.022,
          "neutral": 0.331,
          "positive": 0.647
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.021,
          "neutral": 0.973,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "denehoffman",
        "comment": "I’d say for the majority of my experience has depended on how long I plan on updating the code. For small things that I am working on primarily in Python when I have a couple of functions I just want to run faster, a JIT like Numba or JAX is nice and simple. Sometimes the bottleneck is efficient multithreading and memory management, and in those cases, I personally use Rust. \n\n> Specific performance issue\n\nI needed code that could evaluate a complex function (or many functions) over a large set of datapoints many times, preferably in parallel. JITs didn’t cut it because the core issue was also that Python would load everything into memory and quickly max out my RAM, while still being much slower than C programs I was competing with.\n\n> What tool and why\n\nI chose Rust for a couple of reasons. First, I like how the crate system works, I don’t have to depend on the user to know how to install a bunch of different dependencies via various makefiles, cmake, ninja, meson, etc etc. I also like the memory management, it’s not too manual, but also gives me enough control to be efficient. I don’t mind programming in C/C++, but I certainly don’t enjoy it as much.\n\n> Speedup\n\nIt’s hard to say because I never had the full product working with Python alone, but it has definitely been significantly faster than anything I wrote in Python. Again, I don’t have hard numbers, but it’s orders of magnitude.\n\n> Integration process\n\nDebugging Rust code is easy (skill issue if you can’t figure out what the compiler wants after it explicitly tells you what’s wrong). PyO3 was a bit tricky, since you have to learn how Python actually manages memory, something Python devs can usually ignore. Maturin is not entirely straightforward with how to organize a Python extension or how to actually write the Python API, but I just looked at big projects like polars for inspiration.\n\n> Hindsight\n\nYes, in hindsight I would start with Rust rather than fumbling around with JITs. They’re nice if you don’t know how to use a lower-level language, but in the end they get into edge cases if you use them enough. Complex numbers aren’t really supported in JAX for a number of reasons, and you often have to hand roll linear algebra or complex computations that aren’t JITted, like anything in scipy or scikit-learn.\n\n\nI think the major tradeoff for me was that I had to learn Rust. I don’t regret this, I think it’s made me a better programmer, but it took time and a lot of work to get the Rust code working the way I wanted. I’m so used to OOP it was tricky to get out of that mindset.",
        "score": 2,
        "date": "2025-04-25T15:33:58",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.109,
          "neutral": 0.377,
          "positive": 0.514
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.003,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.989,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "spiker611",
        "comment": "I've used cython for writing device interface drivers.  It's a lot faster for hitting I/O and memory and running tight loops.\n\nThe specific bottleneck/limitation was DMA and in some cases bit-banging pins.  It's so easy to just do it like you would in C.  Then you write some cython-intermediate code and it's great to use their HTML output thing to show you the generated code and where it could be better.\n\nCython got a lot easier to use with cython 3 and type hinting.",
        "score": 2,
        "date": "2025-04-25T21:32:31",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.007,
          "neutral": 0.063,
          "positive": 0.93
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.051,
          "neutral": 0.942,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "c3d10",
        "comment": "I wrote a computational electromagnetics code with a C backend and a Python wrapper. The C code was about 1000x faster than the python code and about 10-50x faster than Numba. \n\nI love writing C code (because it’s so simple and easy for me to understand - my programs are not that complex) but in the same vein I make so many mistakes in memory management that I’ve started to write new code in Rust and noticed a huge improvement in code quality and productivity. ",
        "score": 2,
        "date": "2025-04-26T02:56:50",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.013,
          "neutral": 0.064,
          "positive": 0.923
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.004,
          "fear": 0.001,
          "joy": 0.159,
          "neutral": 0.824,
          "sadness": 0.003,
          "surprise": 0.004
        }
      },
      {
        "user": "v_0ver",
        "comment": "Here is a presentation from my talk where I showed the performance improvement when porting several tasks from `python`\\+`numpy`\\+`numba`\\+etc to `Rust`(`PyO3`): [https://drive.google.com/file/d/1mv4DXHHwth319F23TQKg1-8L5qoKRQ70/view?usp=sharing](https://drive.google.com/file/d/1mv4DXHHwth319F23TQKg1-8L5qoKRQ70/view?usp=sharing) It's in Russian, but the plots are quite obvious. I got a 3-5x speedup and a dramatic reduction in memory consumption.\n\nI write a lot of simple math for data processing for ML. In my work I've moved away from `Cython`, to extensions on `Rust`. I still use `numba` wherever possible because of its simplicity.",
        "score": 2,
        "date": "2025-04-26T10:22:07",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.016,
          "neutral": 0.337,
          "positive": 0.647
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.002,
          "fear": 0.0,
          "joy": 0.033,
          "neutral": 0.958,
          "sadness": 0.001,
          "surprise": 0.003
        }
      },
      {
        "user": "mahmoudimus",
        "comment": "I hated Cython but tried it recently on a native hashing function for a project I am working on. Wow! Type extensions with pure python mode made it trivial. Like a 100x speed up. Pretty incredible. Cython 3 is a game changer.",
        "score": 2,
        "date": "2025-04-27T03:25:16",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.034,
          "neutral": 0.092,
          "positive": 0.874
        },
        "emotion": "joy",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.004,
          "joy": 0.605,
          "neutral": 0.005,
          "sadness": 0.001,
          "surprise": 0.381
        }
      },
      {
        "user": "M4xM9450",
        "comment": "I wrote some small helper functions for a project I was doing that involved large graphs and groupings to do faster set operations and DFS. It was really a night and day difference that I think warrants people who are into Python to look at Rust.",
        "score": 1,
        "date": "2025-04-25T14:51:22",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.022,
          "neutral": 0.456,
          "positive": 0.523
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.02,
          "neutral": 0.971,
          "sadness": 0.001,
          "surprise": 0.004
        }
      },
      {
        "user": "kAROBsTUIt",
        "comment": "I've wrote a C extension for one of my python projects that reads from an SPI peripheral device and processes the results. My project needed to do this as fast as possible, and the C extension sped things up tremendously. Then, I passed the processed results back to Python for higher level integration into the rest of the application. \n\nIt was a bit of a learning curve because it's been years since I touched C, and I was never really great with it. The Python specifics dealing with reference counts was a bit tricky too. But overall it wasn't that bad. I had a couple memory leaks in my C extension that I had to learn how to debug, but once I found those it was rock solid.\n\nSetting up a build pipeline and packaging strategy was equally as difficult, but not too bad either.",
        "score": 1,
        "date": "2025-04-25T19:10:20",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.118,
          "neutral": 0.388,
          "positive": 0.494
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.006,
          "neutral": 0.985,
          "sadness": 0.004,
          "surprise": 0.001
        }
      },
      {
        "user": "spinwizard69",
        "comment": "I look at it this way, python isn’t always the right choice!    \n\nHowever when using Python I generally use somebody else’s native solution.",
        "score": 1,
        "date": "2025-04-25T19:32:43",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.394,
          "neutral": 0.504,
          "positive": 0.103
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.376,
          "disgust": 0.103,
          "fear": 0.013,
          "joy": 0.002,
          "neutral": 0.482,
          "sadness": 0.02,
          "surprise": 0.004
        }
      },
      {
        "user": "armour_de",
        "comment": "I was doing some physics simulations that calculate the total field from a function that operates on two input arrays, and produces an output array of a field.\n\n\nThe two arrays were m x 3 and n x 3 in size, and the function had about fifty operations that were performed.  It was not exactly matrix multiplication but in intermediate steps an m x n x 6 array could be created depending on how it was implemented.\n\n\n\nThe initial naive method was just to implement this on scalars and input Python lists.  List comprehension would then be used to act on the arrays, and the final result reduced to an n x 3 array.  This was very slow, and could use more than 64 gigs of memory for large arrays, but for simple cases you could wait it out.\n\n\nThe first step up in speed was to move to numpy array operations which was faster and more memory efficient than python lists.\n\n\nAt the same time the calculation was changed such that the largest array was n x 3 in the calculation.  This reduced the memory requirements, removed access to the individual contributions of the members, but that was never needed in practice.\n\n\nThis was used for a while, but eventually optimization searches required thousands of different m x 3 input arrays to be calculated at a time. This was taking hours and overnight calculations were common.\n\n\nThe next speed up was to add numba JIT compilation.  This required some re-writing of the function to remove unsupported numpy operations but was a 30-40% reduction in calculation time and reduced the memory requirements so larger arrays could be used, and fewer approximations or interpolations were required between data points.\n\n\nThe next speed up attempt was to write a C function to replace the Python function using ctypes.  This was about a factor of twenty faster on individual rows when tested in pure C code, but converting from Python data types, to C data types and back to Python when calling the function in Python was slower than the numba code by a factor of 2-5 IIRC.  Rather than move all of the data storage to C, we just stuck with the numba code for months.\n\n\nA 20% speed up was found by identifying common terms between different stages of the calculations in the function,  such as if A, B and C are calculated individually and then then several lines later E = D(A/C)/(B/C), just calculate E=DA/B. \n\n\nThis removed the physical interpretation of some intermediate steps, but those didn't need to be referenced after the initial validation of the function. This was used for a few more months.\n\n\n\n\nUsing the Blaze C++ library for array calculations was examined, and it was faster than plain C code as it could parallelize the calculations in the background, but some functions from Python libraries could not easily be ported to C++,  and passing data back and forth between Python and C++ seemed more complicated than was worth the while to program at the time.\n\n\nEventually the optimization efforts grew complicated enough that it was desired to use a genetic algorithm.  This required many more repetitions of the calculation to get to a useful final result , so the main function was converted into a C extension for numpy.  This allowed compiled C code to do the work, and removed the need to convert data types.   This was several times faster than numba.\n\n\nCUDA was beginning to be examined as a solution to running more calculations in parallel speed up the operations, but as no one in the group knew how to use CUDA it was never implemented before a sufficient result was found using the numpy extension over a few weeks of calculation.",
        "score": 1,
        "date": "2025-04-26T01:25:54",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.23,
          "neutral": 0.624,
          "positive": 0.146
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.005,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.985,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "fibncl",
        "comment": "I have tried all before. After balancing between simplicity and speed, I almost always just use numba. Pure C or Rust implementations are faster, but not enough to justify the code complexity. I know how to handle them well, but my colleagues not always, and so I would either have to write really detailed README (which even then often gets neglected), or they won't be willing to build on top of that codebase. Cython gives similar performance gain, but is a lot more complex.",
        "score": 1,
        "date": "2025-04-26T04:05:37",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.265,
          "neutral": 0.497,
          "positive": 0.238
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.008,
          "disgust": 0.007,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.97,
          "sadness": 0.012,
          "surprise": 0.001
        }
      },
      {
        "user": "james_pic",
        "comment": "I've used Cython for improving performance in code that profiling shows is used heavily in hot loops. My experience is that you get (or at least got at the time - this was a while ago and there have been improvements to CPython's interpreter performance since then) about a 30% speed-up from just compiling the code without changing it, and maybe about a 5× speed-up if you were able to replace refcounted types with native types and structs, and eliminate \"yellow lines\" from the generated code.\n\n\nCython has the advantage that it looks like Python, so if you've got a significant number of developers on the team who don't know anything else, there's a better chance they'll be able to work with it, but you're more likely to end up leaving some performance improvement opportunities on the table.",
        "score": 1,
        "date": "2025-04-26T10:05:36",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.055,
          "neutral": 0.364,
          "positive": 0.582
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.003,
          "fear": 0.0,
          "joy": 0.006,
          "neutral": 0.984,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "Frankelstner",
        "comment": "I needed a function to find a line-plane intersection, really just `dp = p2-p; out[:] = p + dp/(dp@wu) * ((P0-p)@wu)` where p,p2 are line points and P0,wu are point and normal unit vector of the plane. Processing in batches was impossible because data arrives in real-time. The main criteria were fast call time from within plain Python code (i.e. no interface friction) and fast import times.\n\nThe code eventually boiled down to a function with three numpy arrays as inputs, where the first array merged P0,wu,out together (the number of inputs has quite an impact on interfacing). Time per one call of this function, where the caller lives in plain Python, as well as import times:\n\n* Plain Python + numpy ops: 5000 ns\n* Plain Python + no numpy ops (using numpy arrays, but manually indexing): 1800 ns\n* Cython: 420 ns (500 µs import)\n* Numba JIT: 250 ns (500 ms import for Numba itself, plus 2 ms for every single Numba function, even when cached, which is horrible)\n* Numba AOT: 170 ns (400 µs import)\n* C with ctypes: 150 ns (300 µs import assuming ctypes is loaded). Requires fetching array pointers beforehand which takes over 1 µs per pointer; and not defining argtypes. I.e. if fetching fresh pointers each time, the time is 3150 ns.\n* C with cffi: 110 ns (2 ms import). Requires 10 µs per pointer fetch. But cffi has so many options that there's probably a better setting out there, so take these results with a grain of salt.\n* Rust with pyo3: 52.5 ns (500 µs import)\n* C API: 40 ns (400 µs import)\n* No interfacing (just the intersection): 3 ns. This is tested by writing an outer function in the same setup which loops over a billion samples (slightly modifying point p on the line each time and tracking output). Whether Cython or Numba or C or Rust, the time is pretty much the same because they all do the same thing. Only the interface differs.\n\nNumba does have some dead ends such as jitclass which sounds like a good idea until you realize that it cannot cache at all and a simple class with 10 attributes and one method takes 4 seconds to compile every time (the near-undocumented StructRefs could fix this though I haven't checked how they interact with AOT).\n\nAll of this considers just a function that receives three numpy arrays. Classes/structs are quite a different matter, and sadly Numba isn't quite as good with them.",
        "score": 1,
        "date": "2025-04-26T14:03:54",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.271,
          "neutral": 0.594,
          "positive": 0.135
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.01,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.982,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "mighalis",
        "comment": "I don't have any metrics in hand, but I strongly suggest Jax. Just in time compilation with GPU parallelization for free -if you want.\nHuge plus the auto-differention capabilities of your functions, which means huge difference in optimization, model fitting etc.\nThe framework is oriented on deep learning, but in reality this is just a set of applications, jax is capable on any type of modeling (+you can mix your models, functions etc with neural networks). I have used it for several applications, from ship route optimization to astrophysics finite volume methods. \nIn my PhD I have heavily used Julia, which have similar capabilities. I would say that jax in comparison is ~1.1 slower (again this is not a measured metric). \n(I also recommend Julia by the way if you are interested )",
        "score": 1,
        "date": "2025-04-25T21:39:34",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.07,
          "neutral": 0.421,
          "positive": 0.509
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.004,
          "fear": 0.001,
          "joy": 0.003,
          "neutral": 0.985,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "coderarun",
        "comment": "Transpiling python to rust and shipping standalone binaries (simple single file apps) or pyO3 extensions is something I'd recommend.\n\nAlso, LLMs have gotten good at some of these cases. For simple cases, have them translate your code. But then, you'll spend some time debugging and fixing issues. \n\nRecommend a combination of the two approaches (AST rewriting, deterministic transpilers) and LLM based probabilistic ones depending on the use case.",
        "score": 1,
        "date": "2025-04-26T00:55:03",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.023,
          "neutral": 0.281,
          "positive": 0.696
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.004,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.988,
          "sadness": 0.002,
          "surprise": 0.001
        }
      }
    ],
    "resumen_mt5": "The BBC's weekly The Boss series profiles different business leaders from around the world. This week we speak to a number of people who have used tools to speed up Python."
  },
  {
    "flair": "Showcase",
    "title": "inline - function & method inliner (by ast)",
    "author": "SamG101_",
    "date": "2025-04-30T19:13:02",
    "score": 164,
    "description": "github: [SamG101-Developer/inline](https://github.com/SamG101-Developer/inline)\n\n# what my project does\n\nthis project is a tiny library that allows functions to be inlined in Python. it works by using an import hook to modify python code before it is run, replacing calls to functions/methods decorated with \\`@inline\\` with the respective function body, including an argument to parameter mapping.\n\nthe readme shows the context in which the inlined functions can be called, and also lists some restrictions of the module.\n\n# target audience\n\nmostly just a toy project, but i have found it useful when profiling and rendering with gprofdot, as it allows me to skip helper functions that have 100s of arrows pointing into the nodes.\n\n# comparison\n\ni created this library because i couldn't find any other python3 libraries that did this. i did find a python2 library [inliner](https://github.com/orf/inliner) and briefly forked it but i was getting weird ast errors and didn't fully understand the transforms so i started from scratch.",
    "comments": [
      {
        "user": "WalkingAFI",
        "comment": "This is a cool idea. I’m also curious about what the performance impact is.",
        "score": 9,
        "date": "2025-04-30T22:49:16",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.002,
          "neutral": 0.037,
          "positive": 0.962
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.005,
          "fear": 0.001,
          "joy": 0.02,
          "neutral": 0.921,
          "sadness": 0.001,
          "surprise": 0.048
        }
      },
      {
        "user": "tomster10010",
        "comment": "Neat! Does it only work with single statement functions? ",
        "score": 3,
        "date": "2025-04-30T20:29:09",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.271,
          "neutral": 0.635,
          "positive": 0.094
        },
        "emotion": "disgust",
        "emotion_probs": {
          "anger": 0.059,
          "disgust": 0.517,
          "fear": 0.003,
          "joy": 0.002,
          "neutral": 0.225,
          "sadness": 0.004,
          "surprise": 0.19
        }
      },
      {
        "user": "LightShadow",
        "comment": "Does it make any noticeable performance difference, or not really? \n\nYes Python interpreted, etc. etc. I'm just wondering if eliminating small functions in a hot loop is worthwhile.\n\nAdditionally, can you explain the `[T]` syntax on this line, `def inline_cls[T](cls: T) -> T:` ?",
        "score": 3,
        "date": "2025-04-30T22:36:18",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.31,
          "neutral": 0.586,
          "positive": 0.104
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.007,
          "disgust": 0.008,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.976,
          "sadness": 0.001,
          "surprise": 0.006
        }
      }
    ],
    "resumen_mt5": "This is a full transcript of SamG101's latest python library."
  },
  {
    "flair": "Discussion",
    "title": "I am a Teacher looking for a career change. Is knowing Python enough to land me a job?",
    "author": "Street-Panic-0",
    "date": "2025-04-28T10:41:30",
    "score": 130,
    "description": "If so which jobs and where do I find them? If not, what else would I need? \n\nAfter 10 years as an English teacher I can't do it any longer and am looking for a career change. I have a lot of skills honed in the classroom and I am wondering if knowing Python on top of this is enough to land me a job?\n\nThanks. ",
    "comments": [
      {
        "user": "Valuable_Tomato_2854",
        "comment": "Brutal truth, no.\n\nJust knowing a programming language means nothing if you:\n\n(1) Do not know what role/s to pursue (e.g. Backend development) \n\n(2) Do not know what the industry standard ways of doing things is for that role (what backend frameworks are used, how they're are used, how is unit testing done, what security practices should be followed, what are the common development design patterns) \n\n(3) Understanding the overall ecosystem of what you are looking to get a job in (e.g. what cloud provider do you know how to work with, what experience do you have with DevOps, what do you know about software architecture)\n\nI hope that helps you to get an idea of what is required to have good chances for getting a role in tech nowadays. There are many paths you can follow, and the backend development i mentioned is only just one. So maybe start by finding what you want to do, and go from there.",
        "score": 384,
        "date": "2025-04-28T10:50:26",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.279,
          "neutral": 0.566,
          "positive": 0.155
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.011,
          "disgust": 0.008,
          "fear": 0.005,
          "joy": 0.001,
          "neutral": 0.972,
          "sadness": 0.003,
          "surprise": 0.001
        }
      },
      {
        "user": "iknowsomeguy",
        "comment": "In today's job market, you're going to have a very hard time without a CS degree, and it gets worse every day. Between AI hype and jobs being outsourced to places where the labor is cheap, the competition is intense. It's not impossible, but there are people with 10YOE struggling to find work. Applying to hundreds of jobs is fairly common, and a lot of those will just filter you out without the degree.\n\nDefinitely don't do anything hasty.",
        "score": 75,
        "date": "2025-04-28T11:10:21",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.769,
          "neutral": 0.199,
          "positive": 0.032
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.012,
          "disgust": 0.067,
          "fear": 0.004,
          "joy": 0.002,
          "neutral": 0.883,
          "sadness": 0.028,
          "surprise": 0.004
        }
      },
      {
        "user": "bicyclegeek",
        "comment": "Right now? No. I’m an experienced dev (6 years) with additional experience as a project manager and a marketer. I do everything right — leetcode work, keep my tech skills current, contribute to open source, and even publish, and it still took me nine months to land a gig. Having Python skills ain’t nearly enough right now.",
        "score": 25,
        "date": "2025-04-28T11:20:57",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.231,
          "neutral": 0.445,
          "positive": 0.324
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.011,
          "disgust": 0.003,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.952,
          "sadness": 0.005,
          "surprise": 0.025
        }
      },
      {
        "user": "dparks71",
        "comment": "Python is a tool that enhances existing skill sets. If you have a CS degree it allows you to apply the concepts you learned there in applications. If you have a mechanical engineering degree, you can apply the calculations and design checks you learned during school and work with code.\n\nEnglish would be extremely niche, you could potentially get work in natural language models, but you shouldn't expect to enroll in a boot camp and have a $100k/year software or web development job, jobs are very competitive now and you need a degree. Furthering those models would require a CS degree, probably a masters. Working with those models would most likely require a connection within an organization doing it already.\n\nUnless you specifically love programming and really want to be a programmer you're probably better off leveraging your skills in an area like marketing or document management/QA/QC for an org that develops reports. I know a decent amount of English teachers that went to law school. Probably a better overlap of your existing skills there.",
        "score": 31,
        "date": "2025-04-28T10:58:22",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.13,
          "neutral": 0.52,
          "positive": 0.35
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.008,
          "neutral": 0.986,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "fuzzyfoozand",
        "comment": "I'm an engineer in big tech and have brought a couple of other people over from various career fields. Gotta pay it forward - feel free to reach out",
        "score": 7,
        "date": "2025-04-28T12:39:46",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.003,
          "neutral": 0.158,
          "positive": 0.839
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.158,
          "disgust": 0.011,
          "fear": 0.023,
          "joy": 0.302,
          "neutral": 0.492,
          "sadness": 0.013,
          "surprise": 0.001
        }
      },
      {
        "user": "edimaudo",
        "comment": "Unfortunately no.  Writing code is only a small part of the job.  Having a decent understanding of systems and architecture is going to be paramaount.  However you can leverage your experience to build interesting tools for teacher or educators.",
        "score": 7,
        "date": "2025-04-28T17:56:51",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.308,
          "neutral": 0.466,
          "positive": 0.226
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.01,
          "neutral": 0.982,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "Fresh_Heron_3707",
        "comment": "Truthfully no. Python is a tool, that’s like saying you’re a mechanic because you can use a drill. If you don’t know industry standards,lingo, and expectations. You’ll just be viewed as a hobbyist.",
        "score": 4,
        "date": "2025-04-28T16:32:38",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.606,
          "neutral": 0.352,
          "positive": 0.042
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.007,
          "disgust": 0.014,
          "fear": 0.001,
          "joy": 0.005,
          "neutral": 0.969,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "mvaliente2001",
        "comment": "Knowing a programming language is a good start, but these things will help you to land a job:\n\n* Knowing version control systems: learn to use git, create an account on github or gitlab, learn how to create branches, resolve merge conflicts, and create pull requests.\n* Knowing about [project management](https://www.atlassian.com/work-management/project-management) and any ticketing system.\n* Learn about internet protocols and web development (even if you're going to work just on the backend side): TCP/IP, HTTP, HTML, javascript.\n* Read about software design (SOLID principles, patterns, etc).\n* Learn about cloud computing (AWS, Gcloud, etc).\n\nThat sounds like a lot, but don't worry. You don't need to master all those things, just being able to understand them, and to interact with them.",
        "score": 5,
        "date": "2025-04-28T18:00:49",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.033,
          "neutral": 0.333,
          "positive": 0.634
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.002,
          "joy": 0.019,
          "neutral": 0.973,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "elghazlani77",
        "comment": "no it's not unless you wanna teach it to kids ina a center/academy",
        "score": 6,
        "date": "2025-04-28T18:24:41",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.259,
          "neutral": 0.683,
          "positive": 0.058
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.002,
          "fear": 0.002,
          "joy": 0.011,
          "neutral": 0.979,
          "sadness": 0.003,
          "surprise": 0.001
        }
      },
      {
        "user": "Evening-Notice-7041",
        "comment": "At this point I would say knowing Python is like knowing Excel. It’s a tool that is so useful in some industries that knowing it is basically a requirement… but nobody gets a job doing just that. \n\nIf you want to be an accountant you NEED to know excel but knowing excel won’t make you an accountant. \n\nSimilarly if you want to be a data scientist you NEED to know Python but knowing Python won’t make you a data scientist.",
        "score": 6,
        "date": "2025-04-29T01:37:30",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.157,
          "neutral": 0.419,
          "positive": 0.424
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.017,
          "disgust": 0.01,
          "fear": 0.003,
          "joy": 0.001,
          "neutral": 0.964,
          "sadness": 0.003,
          "surprise": 0.002
        }
      },
      {
        "user": "AiutoIlLupo",
        "comment": "Absolutely not. I programmed as a scientific developer in python for 20 years and I myself have troubles landing a job as a python developer, and the reason is that they don't want you to know python. They want you to know python, keras, pandas, tensorflow, requests, pytorch, numpy, multiprocessing, cython, pytest, uvicorn, fastapi, uv, black, mypy, bash, powershell, MVC, react, redux, typescript, aws, lambda, cloudformation, redis, postgres, aurora, snowflake, github, github actions, scrum, jira, docker, CI/CD, kubernetes, terraform. Also be proactive and independent, aka: your own manager, while your manager tracks KPI and writes powerpoint. Oh, and you have to know how to invert a list for the job interview.\n\nSpecialisation is over. They don't want an employee. They want a one man army, and pay him like a junior developer.",
        "score": 12,
        "date": "2025-04-28T12:24:53",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.727,
          "neutral": 0.239,
          "positive": 0.034
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.011,
          "disgust": 0.004,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.978,
          "sadness": 0.004,
          "surprise": 0.001
        }
      },
      {
        "user": "thedmandotjp",
        "comment": "Have been where you are.  I got my first python job as a low-level contract worker at a research institute from an ad my wife found in the paper.  After about a year and a half building a website for them from scratch, managed to land something at a large company where I learned tons and am now a fully-fledged back-end python developer.  Yes it's enough, but like anything else you're going to need some luck to get what you want and it won't be easy.",
        "score": 4,
        "date": "2025-04-28T12:01:45",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.052,
          "neutral": 0.31,
          "positive": 0.638
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.01,
          "disgust": 0.001,
          "fear": 0.002,
          "joy": 0.068,
          "neutral": 0.915,
          "sadness": 0.003,
          "surprise": 0.002
        }
      },
      {
        "user": "12candycanes",
        "comment": "I did the same career switch (teaching -> Python developer) but that was ten years ago. I was able to get on with a venture-backed company and get enough experience to get a job somewhere better. \n\nAs many other folks in this thread have observed, with the way the job market is now, it's very unlikely that you'll find anything. Hiring is drastically reduced, and even CS majors with significant internship experience aren't getting roles. It sucks, but that's how it is.\n\nI think where the real interesting opportunity lies for you is in entrepreneurship. Spend time looking at irritating, repititious tasks you have to do in the classroom, then start figuring out how to write software to solve those problems. If you're having to do some irritating task every day (or, even better, every lesson!), other teachers probably are, too, so there's a market for your solution! Start creating solutions with software for these problems. You'll make your teaching life better, maybe create a product that makes you some money, and get meaningful experience and knowledge (and a software portfolio) that will let you work in a tech job in the future.",
        "score": 3,
        "date": "2025-04-28T23:10:54",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.366,
          "neutral": 0.398,
          "positive": 0.236
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.188,
          "disgust": 0.011,
          "fear": 0.011,
          "joy": 0.024,
          "neutral": 0.739,
          "sadness": 0.006,
          "surprise": 0.021
        }
      },
      {
        "user": "frogontrombone",
        "comment": "Have you considered technical writing? A lot of the work is very repetitive and boring... lending itself to automation. Then you can use LaTeX, and maybe Python to speed up data organization into LaTeX",
        "score": 5,
        "date": "2025-04-28T11:07:16",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.666,
          "neutral": 0.287,
          "positive": 0.047
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.99,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "cujojojo",
        "comment": "I’ll give you a little more optimistic take, having done something roughly like what you’re talking about:\n\nMake a Venn diagram. You’re a teacher, so you should LOOOVE that 🙃. Make circles for what you’re good at as a teacher: conveying knowledge, speaking in front of people, planning, dealing with entitled assholes… Probably English-specific stuff, too, like writing or editing. Each circle has a number of people in it, and the number where they all intersect is smaller.\n\nNow add a circle for “Python” to that. How many people are in ALL the circles now? Not many. That’s you. In fact, you might be able to construct a diagram where you’re the *only* person left (do you know any foreign languages? That really narrows things down). Now you have your unique identity, the thing that isn’t in competition with *anybody*. Obviously that doesn’t make jobs magically appear but it does give you a way to talk about yourself in a way that differentiates you. And it helps frame your thinking about the kind of job you want to pursue.\n\nOff the cuff, I would suggest definitely studying (I mean really *studying*) Python or whatever. But where you’ll find more leverage is something like product management or product marketing. A lot of coders (wrongly) look down on those jobs, since they require a more fused skill set that *you have*. Go to networking events for that sort of thing, tell people exactly the transition you’re trying to make.\n\nAnd once you get a position doing something like that, it gets you much closer to coding, if that’s (still) what you really want. Which enables the next step, etc.\n\nOne more thing: *This may take a while*. You might be talking 5 years before you look around and realize, “Hey, I made it.” You might get lucky and skip a bunch of steps, but probably not. It’s a bit of a walk, but it *can* be done.",
        "score": 6,
        "date": "2025-04-28T11:34:36",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.135,
          "neutral": 0.528,
          "positive": 0.337
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.007,
          "disgust": 0.006,
          "fear": 0.001,
          "joy": 0.012,
          "neutral": 0.971,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "muikrad",
        "comment": "Creating games is maybe one field where you can benefit from learning one (and only one) language. But that language wouldn't be python, it would be tied to whichever gaming engine you decide to learn.\n\nGood luck!",
        "score": 4,
        "date": "2025-04-28T10:56:27",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.021,
          "neutral": 0.236,
          "positive": 0.744
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.027,
          "disgust": 0.003,
          "fear": 0.001,
          "joy": 0.16,
          "neutral": 0.804,
          "sadness": 0.001,
          "surprise": 0.004
        }
      },
      {
        "user": "cleverdirge",
        "comment": "If you have teaching skills and are technical enough to learn some programming, why not shoot for a project manager or product manager?",
        "score": 2,
        "date": "2025-04-28T11:37:10",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.07,
          "neutral": 0.823,
          "positive": 0.107
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.007,
          "disgust": 0.004,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.981,
          "sadness": 0.001,
          "surprise": 0.004
        }
      },
      {
        "user": "perfectm",
        "comment": "I would consider blending your experiences and consider teaching python.  Private programming lessons for teenagers would earn a very good hourly rate.",
        "score": 2,
        "date": "2025-04-28T13:48:55",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.004,
          "neutral": 0.149,
          "positive": 0.847
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.014,
          "neutral": 0.978,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "BinaryBillyGoat",
        "comment": "As a high school student who has been programming for about five years and has built education tools used by two division one colleges, having an English teacher that has a basic understanding of imperative logic would be incredible. I don't know if your Python skills are good enough for a career change, but I can say for sure that good teachers are few and far between. If you are a good teacher, I would really suggest sticking around.",
        "score": 2,
        "date": "2025-04-28T17:54:19",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.158,
          "neutral": 0.413,
          "positive": 0.429
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.003,
          "fear": 0.005,
          "joy": 0.026,
          "neutral": 0.958,
          "sadness": 0.001,
          "surprise": 0.003
        }
      },
      {
        "user": "slept3hourslastnight",
        "comment": "Absolutely not. Especially in this job market climate. \n\nAt this time, you’ll need a CS degree, relevant job experience, and interviewing skills.\n\nIt’s really not the time to get into tech rn",
        "score": 2,
        "date": "2025-04-28T18:10:47",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.716,
          "neutral": 0.246,
          "positive": 0.038
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.001,
          "fear": 0.003,
          "joy": 0.001,
          "neutral": 0.982,
          "sadness": 0.005,
          "surprise": 0.003
        }
      },
      {
        "user": "Ill-Union-8960",
        "comment": "absolutely not.  python is useful but is just one skill in the toolbox of any developer.  people who only use python at work usually have another primary skillset like data science or ml.",
        "score": 2,
        "date": "2025-04-28T18:47:17",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.199,
          "neutral": 0.482,
          "positive": 0.319
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.005,
          "neutral": 0.986,
          "sadness": 0.003,
          "surprise": 0.001
        }
      },
      {
        "user": "EfficientOlive7013",
        "comment": "I quit teaching exactly 3 years ago and I’m starting in two weeks at FAANG. It is possible, you’ve got to put in the work though. Don’t listen to the doomers.",
        "score": 2,
        "date": "2025-05-01T02:47:01",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.282,
          "neutral": 0.515,
          "positive": 0.203
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.104,
          "disgust": 0.038,
          "fear": 0.068,
          "joy": 0.002,
          "neutral": 0.732,
          "sadness": 0.051,
          "surprise": 0.004
        }
      },
      {
        "user": "Game-of-pwns",
        "comment": "I was a teacher for four years. One summer, I got a Comptia A+ certification, learned python (Learn Python the Hard Way) and basic web development (Udacity). It was enough to get me an entry level job in software support. I'm still in tech 10 years later and make  triple what I did as a teacher. \n\nYou can do it.",
        "score": 5,
        "date": "2025-04-28T11:26:29",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.012,
          "neutral": 0.131,
          "positive": 0.858
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.019,
          "disgust": 0.003,
          "fear": 0.002,
          "joy": 0.178,
          "neutral": 0.795,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "The_GSingh",
        "comment": "No. Not at all.",
        "score": 3,
        "date": "2025-04-28T10:59:43",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.526,
          "neutral": 0.419,
          "positive": 0.055
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.01,
          "disgust": 0.059,
          "fear": 0.002,
          "joy": 0.002,
          "neutral": 0.902,
          "sadness": 0.022,
          "surprise": 0.002
        }
      },
      {
        "user": "Afraid_Palpitation10",
        "comment": "No",
        "score": 2,
        "date": "2025-04-28T11:16:52",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.32,
          "neutral": 0.495,
          "positive": 0.185
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.44,
          "disgust": 0.059,
          "fear": 0.005,
          "joy": 0.001,
          "neutral": 0.453,
          "sadness": 0.018,
          "surprise": 0.023
        }
      },
      {
        "user": "bitcraft",
        "comment": "5 years ago, it probably could work with the right company and if you had some projects you could use as a portfolio.  Market is tough, and hiring is very hard due to fake applicants, liars, and saturation.  It wouldn’t be impossible, but you’d have to be exceptionally good and also find the right company.  Best of luck. ",
        "score": 1,
        "date": "2025-04-28T10:57:56",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.096,
          "neutral": 0.322,
          "positive": 0.582
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.001,
          "fear": 0.015,
          "joy": 0.008,
          "neutral": 0.96,
          "sadness": 0.008,
          "surprise": 0.001
        }
      },
      {
        "user": "StoneAgainstTheSea",
        "comment": "my move from teaching to software development story might not be as relevant these days. 15 years ago, I was faced with layoffs being a relatively new teacher during budget cuts. I put out teaching and programming resumes and was able to get a couple of interviews by way of a recruiter, and a start-up took me on. Best thing, career wise, to ever happen to me. \n\nWhy did they take me on? Because I had independent projects that I could talk about mostly. The course supplies sharing website I made for us teachers while we designed a new curriculum was the most relevant. But I could talk about a couple toy customer management solution projects I had put out. I could talk intelligently enough about shipping php and mysql projects (go LAMP stack) and could answer the four different interviewer's questions mostly around from some js and html/css stuff. I had read a couple programming books, web design books, and was passingly familiar with mysql -- I could left join :goldstar: :haha:.  Amazingly, they took me on as a mid-level developer.  I had never even heard of a unit test, though that didn't come up in the interview.\n\nBest of luck!",
        "score": 1,
        "date": "2025-04-28T11:28:43",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.022,
          "neutral": 0.136,
          "positive": 0.842
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.023,
          "disgust": 0.001,
          "fear": 0.008,
          "joy": 0.325,
          "neutral": 0.46,
          "sadness": 0.002,
          "surprise": 0.182
        }
      },
      {
        "user": "wineblood",
        "comment": "Just Python? No. Most jobs that involve Python require a bunch of other skills/tools to be useful, even fresh graduates should have some of those skills.\n\nI don't think a career switch is impossible and you'll probably get some leniance for having a decade of work experience. What I would suggest is building something small from start to finish and doing a reasonable job at all aspects of it.\n\nLet's say you wanted to get a backend dev job (that's what I do), then having a small REST API under your belt would make a big difference. If you can demonstrate having done not just Python code, but documentation, testing, using version control, familiarity with a framework, used a database, and some cloud services knowledge, then you'd have a reasonable chance.",
        "score": 1,
        "date": "2025-04-28T11:30:05",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.062,
          "neutral": 0.445,
          "positive": 0.493
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.013,
          "disgust": 0.006,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.974,
          "sadness": 0.001,
          "surprise": 0.003
        }
      },
      {
        "user": "No_emotion22",
        "comment": "If you want to change your career to Software Engineer, I would strongly recommend start from it manager or junior data analyst/ data scientist. Or automated testing engineer. Strong skills with Python and Sql and database systems will be enough for junior positions. \n\nPs: I know it might sound usual but, if you rerolling just because of money or something else, not the passion or enthusiasm to constantly learn and improve. Like doing your job as a lifestyle every day and every where. If you feel that, Do it! \nIf not there is a lot of other things you can do with much less effort.",
        "score": 1,
        "date": "2025-04-28T11:35:33",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.078,
          "neutral": 0.411,
          "positive": 0.511
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.019,
          "disgust": 0.007,
          "fear": 0.018,
          "joy": 0.004,
          "neutral": 0.948,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "sarc-tastic",
        "comment": "What country are you based",
        "score": 1,
        "date": "2025-04-28T11:50:56",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.148,
          "neutral": 0.788,
          "positive": 0.064
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.978,
          "sadness": 0.001,
          "surprise": 0.017
        }
      },
      {
        "user": "rainyengineer",
        "comment": "Try visiting r/learnpython. You could pick it up just for fun for now, but to be real with you it takes a couple years of self-learning realistically and a fortunate job market to make the switch (which we don’t have right now. People seem to flock to becoming a software engineer as an overnight solution for jobs they hate, but it takes time. \n\nI did just this and it took about two years and I’d say I was lucky to land a job. Still thankful for it. \n\nHere’s what you could do though. You could pick up some lighter skills and try to get into a large corporation in a non-technical role. Seek out project management, a governance role (maybe ITIL related), or something in operations management. Then you can breathe easier and begin to network and make contacts as you begin to upskilling technically if that’s still what you’d like to do.",
        "score": 1,
        "date": "2025-04-28T11:54:27",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.056,
          "neutral": 0.284,
          "positive": 0.66
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.005,
          "neutral": 0.985,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "Ok-Bug8833",
        "comment": "Python is the Lingua Franca of data science.\n\n\nSo the way to approach this might be:\n-im interested in a grad role in this analytics team, and I have this python skill to offer\n\n\nIt's something which is a great skill to have but you still need to advance your experience on the job in the normal way.\n\n\nPossible areas to look into:\nAnalytics, data science.",
        "score": 1,
        "date": "2025-04-28T12:12:48",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.008,
          "neutral": 0.14,
          "positive": 0.851
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.003,
          "neutral": 0.992,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "LairdPeon",
        "comment": "I absolutely would NOT learn a language in anticipation that I'd get a job. In the current market, you need to be an engineer to have value. I can't begin to predict the future market.",
        "score": 1,
        "date": "2025-04-28T12:37:29",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.834,
          "neutral": 0.151,
          "positive": 0.015
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.076,
          "disgust": 0.011,
          "fear": 0.144,
          "joy": 0.005,
          "neutral": 0.701,
          "sadness": 0.06,
          "surprise": 0.002
        }
      },
      {
        "user": "kevinpl07",
        "comment": "Other people have already said that it’s gonna be hard without a degree.\n\nApart from that, I’m not sure python specifically is beneficial as a choice. It’s great for machine learning and scripting but also not used in many „simpler“ products. Also it’s the entry language for many students so you’d compete with.\n\nSo you’d compete with many people for few jobs.",
        "score": 1,
        "date": "2025-04-28T12:37:42",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.254,
          "neutral": 0.459,
          "positive": 0.287
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.005,
          "fear": 0.0,
          "joy": 0.002,
          "neutral": 0.982,
          "sadness": 0.006,
          "surprise": 0.002
        }
      },
      {
        "user": "mkeee2015",
        "comment": "Which country?",
        "score": 1,
        "date": "2025-04-28T12:45:59",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.167,
          "neutral": 0.798,
          "positive": 0.035
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.954,
          "sadness": 0.001,
          "surprise": 0.039
        }
      },
      {
        "user": "liquidpele",
        "comment": "No but it's a good first step...   just knowing some python is akin to having creds as a substitute teacher and wanting to get into teaching, you have a ways to go.",
        "score": 1,
        "date": "2025-04-28T13:19:55",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.059,
          "neutral": 0.335,
          "positive": 0.606
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.001,
          "fear": 0.002,
          "joy": 0.032,
          "neutral": 0.957,
          "sadness": 0.003,
          "surprise": 0.001
        }
      },
      {
        "user": "thedoogster",
        "comment": "Any visual arts skills? Animation (including VFX) is a possible option.",
        "score": 1,
        "date": "2025-04-28T13:31:24",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.007,
          "neutral": 0.747,
          "positive": 0.247
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.001,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.017,
          "neutral": 0.975,
          "sadness": 0.001,
          "surprise": 0.004
        }
      },
      {
        "user": "Suspect4pe",
        "comment": "Knowing the basic language? No. Pick what area you want to go into and start picking up online or local college courses that fit. \n\nData analytics is big and will continue to be. Pandas is a great way to query and work with data. Investigate and see if that's an area you might be interested and then maybe just pick up a book and start working with it?",
        "score": 1,
        "date": "2025-04-28T14:01:36",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.008,
          "neutral": 0.226,
          "positive": 0.766
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.002,
          "fear": 0.005,
          "joy": 0.007,
          "neutral": 0.976,
          "sadness": 0.0,
          "surprise": 0.003
        }
      },
      {
        "user": "projector_man",
        "comment": "I was in a similar position, working at a school, learned to code and eventually moved to industry.\n\n\nIt's hard, as others have mentioned. What really helped was learning and using the auxiliary tools, like docker and git. And writing, deploying and maintaining an online registration tool for the school was a big help. \n\n\nInteresting for me the hardest part was getting in a more commercial mindset. That kind of thinking didn't exist in the school, and took quite a shift in moving out. Actions often need to be framed around the needs of the business, which are very different to the needs of a school",
        "score": 1,
        "date": "2025-04-28T14:08:54",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.12,
          "neutral": 0.452,
          "positive": 0.428
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.004,
          "fear": 0.003,
          "joy": 0.003,
          "neutral": 0.958,
          "sadness": 0.027,
          "surprise": 0.002
        }
      },
      {
        "user": "menge101",
        "comment": "Look for jobs where the classroom skills set you apart.  Think of any software you used, saw, or talked about while teaching.  All those may really value a junior engineer with classroom insidght, especially startups in the education space.",
        "score": 1,
        "date": "2025-04-28T14:10:57",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.013,
          "neutral": 0.287,
          "positive": 0.7
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.044,
          "neutral": 0.945,
          "sadness": 0.001,
          "surprise": 0.005
        }
      },
      {
        "user": "Digimub",
        "comment": "No",
        "score": 1,
        "date": "2025-04-28T14:14:05",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.32,
          "neutral": 0.495,
          "positive": 0.185
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.44,
          "disgust": 0.059,
          "fear": 0.005,
          "joy": 0.001,
          "neutral": 0.453,
          "sadness": 0.018,
          "surprise": 0.023
        }
      },
      {
        "user": "spacyoddity",
        "comment": "you could definitely leverage your experience into a developer relations/devrel job or a technical writing one. you will have to be creative about explaining how your skills transfer but it's doable.",
        "score": 1,
        "date": "2025-04-28T14:14:14",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.007,
          "neutral": 0.156,
          "positive": 0.838
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.001,
          "fear": 0.003,
          "joy": 0.017,
          "neutral": 0.97,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "macumazana",
        "comment": "No. Learn ml then yes",
        "score": 1,
        "date": "2025-04-28T14:14:41",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.165,
          "neutral": 0.712,
          "positive": 0.123
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.009,
          "fear": 0.004,
          "joy": 0.001,
          "neutral": 0.977,
          "sadness": 0.003,
          "surprise": 0.001
        }
      },
      {
        "user": "Durloctus",
        "comment": "Without any experience in the tech world using python and sql, probably not. There’s people with masters and phds in data science that can’t find jobs right now.\n\nAnd if I interviewed you, I don’t care if you ‘know’ python; only that you’ve done something _with_ python that solved some problem, and that you can be articulate about it.",
        "score": 1,
        "date": "2025-04-28T14:16:04",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.406,
          "neutral": 0.461,
          "positive": 0.133
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.041,
          "disgust": 0.088,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.842,
          "sadness": 0.02,
          "surprise": 0.006
        }
      },
      {
        "user": "MissingSnail",
        "comment": "So, as a teacher, think about breaking into tech by doing technical writing, technical training, or customer support. Learning Python to build a technical writing portfolio will be different than learning Python to build a programming job portfolio, but will show that you have technical skills.\n\nDepending on what local companies are doing, programming may not be the most important tech skill. You might consider learning about “the cloud” instead or in additoon [https://aws.amazon.com/training/skills-centers/](https://aws.amazon.com/training/skills-centers/)\n\nBe aware that getting your first job in tech as a non traditional candidate will be hard, and a tough tech job market will make it harder.",
        "score": 1,
        "date": "2025-04-28T14:36:41",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.46,
          "neutral": 0.441,
          "positive": 0.1
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.006,
          "neutral": 0.986,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "roastmecerebrally",
        "comment": "That is where I started as a teacher - got me a research associate position (physics degree helped lol) and then data science and now data engineering",
        "score": 1,
        "date": "2025-04-28T14:38:06",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.005,
          "neutral": 0.32,
          "positive": 0.675
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.002,
          "fear": 0.005,
          "joy": 0.215,
          "neutral": 0.768,
          "sadness": 0.004,
          "surprise": 0.002
        }
      },
      {
        "user": "Mithrandir2k16",
        "comment": "Why do a complete 180? If you're and english teacher you're bound to have great language and writing skills. Coupled with an interest for technical things and programming, why not apply to jobs writing technical documentation or user manuals? If you know programming and git basics you might even be able to interact with tooling the company uses.\n\nPeople like these are rare hard to find, maybe you can give that a try.",
        "score": 1,
        "date": "2025-04-28T15:20:08",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.079,
          "neutral": 0.422,
          "positive": 0.5
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.007,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.01,
          "neutral": 0.972,
          "sadness": 0.0,
          "surprise": 0.009
        }
      },
      {
        "user": "Synth_Sapiens",
        "comment": "In 2025 your best (and probably the only as well ) bet is to develop an AI-based project to solve a real problem in education.\nBuy a $20 ChatGPT sub and talk to it.\n\n\nWithin few years education will be totally different - teaching will be done by AI while teachers will become guides, mentors or even friends for the kids. ",
        "score": 1,
        "date": "2025-04-28T15:38:20",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.02,
          "neutral": 0.26,
          "positive": 0.721
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.012,
          "disgust": 0.003,
          "fear": 0.004,
          "joy": 0.011,
          "neutral": 0.967,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "cyrixlord",
        "comment": "I would say that python is a skill, not a career. Now if you got really good with pyval or some scientific tooling or debugging with Python there might be a chance but even that industry is being hit hard be layoffs",
        "score": 1,
        "date": "2025-04-28T15:41:30",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.213,
          "neutral": 0.522,
          "positive": 0.265
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.003,
          "fear": 0.006,
          "joy": 0.004,
          "neutral": 0.869,
          "sadness": 0.111,
          "surprise": 0.001
        }
      },
      {
        "user": "feembly",
        "comment": "Yes as long as the job isn't centered on knowing Python. Python is the tool, and just like how you wouldn't become a mechanic just by \"knowing wrenches,\" you would need experience building things to get the job. \n\nThere are many jobs where a little programming goes a long way. I can't tell you the number of times I've saved myself hours of work by writing a few lines of code, and no shortage of non technical jobs have those sorts of problems. \n\nPersonally, I'd recommend learning python because it's useful and fun, and don't sweat how it specifically plays into your career plans until they are more concrete.",
        "score": 1,
        "date": "2025-04-28T15:48:31",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.067,
          "neutral": 0.243,
          "positive": 0.69
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.003,
          "fear": 0.001,
          "joy": 0.004,
          "neutral": 0.986,
          "sadness": 0.001,
          "surprise": 0.001
        }
      }
    ],
    "resumen_mt5": "The BBC's weekly The Boss series profiles different business leaders from around the world. This week we speak to a teacher who is looking to find work."
  },
  {
    "flair": "Resource",
    "title": "Debugging Python f-string errors",
    "author": "brandonchinn178",
    "date": "2025-04-27T16:21:44",
    "score": 120,
    "description": "https://brandonchinn178.github.io/posts/2025/04/26/debugging-python-fstring-errors/\n\nToday, I encountered a fun bug where f\"{x}\" threw a TypeError, but str(x) worked. Join me on my journey unravelling what f-strings do and uncovering the mystery of why an object might not be what it seems.",
    "comments": [
      {
        "user": "sitbon",
        "comment": "Sounds like a library that misbehaved badly, but also why are you still on 3.8? It has been EOL since last October...",
        "score": 20,
        "date": "2025-04-27T23:33:59",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.833,
          "neutral": 0.156,
          "positive": 0.011
        },
        "emotion": "disgust",
        "emotion_probs": {
          "anger": 0.029,
          "disgust": 0.694,
          "fear": 0.005,
          "joy": 0.002,
          "neutral": 0.11,
          "sadness": 0.087,
          "surprise": 0.072
        }
      },
      {
        "user": "eztab",
        "comment": "Yeah, ideally I'd argue that only `__str__` should exist and support all the formatting, including `repr` functionality.\nWould love to have \"formatting options\" for repr too, like requesting a representation as executable python code.",
        "score": 18,
        "date": "2025-04-27T17:25:26",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.048,
          "neutral": 0.412,
          "positive": 0.54
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.004,
          "fear": 0.0,
          "joy": 0.007,
          "neutral": 0.983,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "InvaderToast348",
        "comment": "Interesting read, thanks :)",
        "score": 6,
        "date": "2025-04-27T19:31:45",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.002,
          "neutral": 0.014,
          "positive": 0.985
        },
        "emotion": "joy",
        "emotion_probs": {
          "anger": 0.001,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.971,
          "neutral": 0.024,
          "sadness": 0.0,
          "surprise": 0.003
        }
      },
      {
        "user": "teije01",
        "comment": "Temporal user here who has also been affected by the sandbox, I feel you pain! Very interesting read!",
        "score": 1,
        "date": "2025-04-28T03:43:48",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.068,
          "neutral": 0.294,
          "positive": 0.638
        },
        "emotion": "joy",
        "emotion_probs": {
          "anger": 0.001,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.975,
          "neutral": 0.012,
          "sadness": 0.001,
          "surprise": 0.009
        }
      },
      {
        "user": "DoingItForEli",
        "comment": "I built a container the other day and started getting errors where double apostrophes were used instead of single, but the code ran fine for months when it was ran from the command line. So something like this is wrong: f“Number of datasets: {results.get(“total”)}” - needs to be ‘total’. So that was fun.",
        "score": 1,
        "date": "2025-04-28T09:28:40",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.47,
          "neutral": 0.361,
          "positive": 0.169
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.025,
          "disgust": 0.055,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.904,
          "sadness": 0.008,
          "surprise": 0.006
        }
      },
      {
        "user": "gerardwx",
        "comment": "Well, okay, but rather than lamenting your \"lost 3 hours,\" what are your key takeaways so it doesn't cost you three hours next time?",
        "score": 1,
        "date": "2025-04-28T12:36:42",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.561,
          "neutral": 0.403,
          "positive": 0.036
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.034,
          "disgust": 0.008,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.944,
          "sadness": 0.002,
          "surprise": 0.009
        }
      }
    ],
    "resumen_mt5": "It's been a week since I started getting f-string errors."
  },
  {
    "flair": "Showcase",
    "title": "lblprof: Easily see your python code’s performance, Line by Line",
    "author": "PhilosopherWrong6851",
    "date": "2025-04-28T21:24:48",
    "score": 107,
    "description": "Hello [r/Python](https://www.reddit.com/r/Python/),\n\nI built this small python package ([lblprof](https://github.com/le-codeur-rapide/lblprof)) because I needed it for other projects optimization (also just for fun haha) and **I would love to have some feedback on it.**\n\n# What my project Does ?\n\nThe goal is to be able to know very quickly how much time was spent on each line during my code execution.\n\nI don't aim to be precise at the nano second like other lower level profiling tool, but I really care at seeing **easily** where my 100s of milliseconds are spent. I built this project to replace the old good `print(start - time.time())` that I was abusing.\n\nThis package profile your code and display a tree in the terminal showing the duration of each line (you can expand each call to display the duration of each line in this frame)\n\nExample of the terminal UI: [terminalui\\_showcase.png (1210×523)](https://raw.githubusercontent.com/le-codeur-rapide/lblprof/refs/heads/main/docs/terminalui_showcase.png)\n\n# Target Audience\n\nDevs who want a quick insight into how their code’s execution time is distributed. (what are the longest lines ? Does the concurrence work ? Which of these imports is taking so much time ? ...)\n\n# Installation\n\n    pip install lblprof\n\nThe only dependency of this package is pydantic, the rest is standard library.\n\n# Usage\n\nThis package contains **4 main functions**:\n\n* `start_tracing()`: Start the tracing of the code.\n* `stop_tracing()`: Stop the tracing of the code, build the tree and compute stats\n* `show_interactive_tree(min_time_s: float = 0.1)`: show the interactive duration tree in the terminal.\n* `show_tree()`: print the tree to console.\n\n&#8203;\n\n    from lblprof import start_tracing, stop_tracing, show_interactive_tree, show_tree\n    start_tracing()\n    \n    # Your code here (Any code) \n    \n    stop_tracing() \n    show_tree() # print the tree to console \n    show_interactive_tree() # show the interactive tree in the terminal\n\nThe interactive terminal is based on built in library [curses](https://docs.python.org/3/howto/curses.html)\n\n# Comparison\n\nThe problem I had with other famous python profiler (ex: [line\\_profiler](https://github.com/pyutils/line_profiler), [snakeviz](https://jiffyclub.github.io/snakeviz/), [yappi](https://github.com/sumerc/yappi)...) are:\n\n* **Profiling the code was too complicated** (refact my code into functions to use the decorators, the profiler will generate raw data that I will have to open with an other tool, it will profile my function but when I see that function1(abc) is too long, I have to go profile this function...\n* **The result of the profiling was hard to interpret** (pointers, low level machine code references I don't understand, lot of information I don't need, it often shows information about lines of code from imported modules, it is hard to navigate across frames etc...)\n\nWhat do you think ? Do you have any idea of how I could improve it ?\n\nlink of the repo: [le-codeur-rapide/lblprof: Easy line by line time profiler for python](https://github.com/le-codeur-rapide/lblprof/tree/main)  \nThank you !",
    "comments": [
      {
        "user": "txprog",
        "comment": "Have you ever try \"uvx pyinstrument yourapp.py\" ?",
        "score": 22,
        "date": "2025-04-28T21:43:04",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.073,
          "neutral": 0.881,
          "positive": 0.045
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.0,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.989,
          "sadness": 0.001,
          "surprise": 0.006
        }
      },
      {
        "user": "BossOfTheGame",
        "comment": "FYI, we are working on an update to line-profiler where you will specify the module you want to profile (which could be your entire app), and it will effectively insert the decorators for you using AST magic. \n\nIt currently has the ability to do this, but the behavior is a bit weird. Technically right now you can do something like:\n\n    cd \"$(python -c \"import uuid, os; print(os.path.dirname(uuid.__file__))\")\"\n    kernprof -lvr -p uuid.py uuid.py\n\nTo tell it to run the uuid.py script and also profile it. Adding the `-vr` will make it pretty-print results at the end. \n\nE.g.\n\n\n    Total time: 2.9e-06 s\n    File: uuid.py\n    Function: __str__ at line 283\n    \n    Line #      Hits         Time  Per Hit   % Time  Line Contents\n    ==============================================================\n       283                                               def __str__(self):                                           \n       284         1          1.5      1.5     50.6          hex = '%032x' % self.int                                 \n       285         1          0.7      0.7     23.0          return '%s-%s-%s-%s-%s' % (                              \n       286         1          0.8      0.8     26.3              hex[:8], hex[8:12], hex[12:16], hex[16:20], hex[20:])\n    \n\nI'm thining for the 5.x release we may make changes to the defaults so the common use-case will look more like:\n\n`kernprof -p uuid -m uuid` \n\nor even just\n\n`kernprof -m uuid` \n\nif you have a pyproject.toml that lists the modules you want profiled.",
        "score": 15,
        "date": "2025-04-29T01:34:25",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.234,
          "neutral": 0.641,
          "positive": 0.125
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.99,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "websterjohnloveland",
        "comment": "Good clean code. You demonstrate a solid understanding of python and of tracing tools. I’ve been developing in python for a long time and you taught me some things.",
        "score": 15,
        "date": "2025-04-29T03:14:20",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.003,
          "neutral": 0.054,
          "positive": 0.943
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.004,
          "fear": 0.001,
          "joy": 0.119,
          "neutral": 0.869,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "james_pic",
        "comment": "For some of the kinds of problems you're aiming to solve, I've usually found I can get good results with Py-Spy. What's your take on it?",
        "score": 6,
        "date": "2025-04-28T23:09:24",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.005,
          "neutral": 0.147,
          "positive": 0.848
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.979,
          "sadness": 0.001,
          "surprise": 0.011
        }
      },
      {
        "user": "moonzdragoon",
        "comment": "*The interactive terminal is based on built in library curses*\n\nGoodbye Windows 😅\n\nBut in OP's defense, afaik, there's not much real equivalent for Windows, at least one that is still maintained and doesn't have way too many dependencies.",
        "score": 3,
        "date": "2025-04-29T08:20:31",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.299,
          "neutral": 0.515,
          "positive": 0.187
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.012,
          "disgust": 0.006,
          "fear": 0.0,
          "joy": 0.004,
          "neutral": 0.969,
          "sadness": 0.007,
          "surprise": 0.001
        }
      },
      {
        "user": "gggggmi99",
        "comment": "Ah yes, Python, my language of choice for speed\n\nSeriously though, cool project and it’ll satisfy my curiosity if nothing else",
        "score": -5,
        "date": "2025-04-29T06:54:42",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.003,
          "neutral": 0.029,
          "positive": 0.968
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.003,
          "neutral": 0.991,
          "sadness": 0.001,
          "surprise": 0.001
        }
      }
    ],
    "resumen_mt5": "This is a project that aims to explain how much time each line takes during its execution."
  },
  {
    "flair": "Discussion",
    "title": "How does Python 3.13 perform vs 3.11 in single-threaded mode?",
    "author": "kimtaengsshi9",
    "date": "2025-04-27T08:40:56",
    "score": 100,
    "description": "When Python 3.12 was released, I had held back from migrating my Python 3.11 applications as there were some mixed opinions back then about Python 3.12's performance vs 3.11. Then, 3.13 was released, and I decided to give it some time to mature before evaluating it.\n\nNow, we're in Python 3.13.3 and the last bugfix release of 3.11 is out. When I Google'd, I only found performance studies on Python 3.13 in its experimental free-threaded mode, which is definitely slower than 3.11. However, I found nothing about 3.13 in regular GIL mode.\n\nWhat are you guys' thoughts on this? Performance-wise, how is Python 3.13 compared to Python 3.11 when both are in GIL-enabled, single-threaded mode? Does the experimental JIT compiler in 3.13 help in this regard?",
    "comments": [
      {
        "user": "latkde",
        "comment": "There are lots of different ways to measure performance. If you care about a specific workload, you'll have to benchmark it yourself.\n\nThere are various resources that compare performance between different Python versions or describe optimization work:\n\n* https://lost.co.nz/articles/sixteen-years-of-python-performance/\n* https://speed.python.org/\n* https://github.com/faster-cpython ← includes archives of benchmark results\n\nThe TL;DR is that CPython tends to make performance improvements with every release, though individual benchmarks might see regressions. Historically, there was a large regression when switching to Python 3, but that is irrelevant now. Python 3.11 saw significant work on performance (reported as 25% average uplift in the [release notes](https://docs.python.org/3/whatsnew/3.11.html#whatsnew311-faster-cpython)).\n\nWhile you can expect Python 3.13 to be a bit faster, it focused on laying the groundwork for larger optimizations in the future (JIT, free-threaded mode). Those features are too experimental to be used in production, though.\n\nIf you care about the last 5% of performance, I'd recommend compiling Python yourself with optimizations for your specific CPU architecture. Pre-built binaries tend to sacrifice a bit of performance for broader compatibility.",
        "score": 78,
        "date": "2025-04-27T09:11:09",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.102,
          "neutral": 0.572,
          "positive": 0.326
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.004,
          "neutral": 0.99,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "nekokattt",
        "comment": "This sounds like the sort of thing you could do some benchmarks on and share your results for the next person and to get technical feedback on the outcomes.",
        "score": 167,
        "date": "2025-04-27T08:43:48",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.027,
          "neutral": 0.784,
          "positive": 0.188
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.015,
          "fear": 0.0,
          "joy": 0.014,
          "neutral": 0.959,
          "sadness": 0.001,
          "surprise": 0.006
        }
      },
      {
        "user": "MicahM_",
        "comment": "I love how everyone is replying to just test it yourself as if this is some crazy concept that nobody would have an answer to. I mean I'm not gonna go do it but I'm sure someone out there knows and it's not thay crazy of an ask lol",
        "score": 32,
        "date": "2025-04-27T12:43:23",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.071,
          "neutral": 0.315,
          "positive": 0.614
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.072,
          "disgust": 0.085,
          "fear": 0.005,
          "joy": 0.364,
          "neutral": 0.459,
          "sadness": 0.005,
          "surprise": 0.01
        }
      },
      {
        "user": "DataPastor",
        "comment": "For my use cases (ML/AI pipelines) the performance has improved a bit between 3.10 to 3.13, but it doesn’t really matter. What really matters is carefully coded, vectorized matrix operations (avoiding for loops and iterrows), profiling and optimizing each transformation steps; and switching from pandas to polars (this latter is responsible for a 40x speedup alone).",
        "score": 15,
        "date": "2025-04-27T09:23:11",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.053,
          "neutral": 0.376,
          "positive": 0.571
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.005,
          "fear": 0.0,
          "joy": 0.005,
          "neutral": 0.983,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "TheHe4rtless",
        "comment": "Not thoughts, just metrics. Carve out some code, run it and as u/nekokattt suggested, share here.",
        "score": 12,
        "date": "2025-04-27T09:11:46",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.065,
          "neutral": 0.854,
          "positive": 0.081
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.006,
          "neutral": 0.989,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "mr-figs",
        "comment": "Performance is noticeably better for me.\nI've been makiing [my game](https://store.steampowered.com/app/3122220/Mr_Figs) for the last 4 years in Python/Pygame. When I jumped from 3.12 to 3.13 there was noticeable improvements even without benchmarking.\n\nThe FPS counter was about 5/6 FPS higher. A big win for a game and a huge win for stuff that isn't so intense.\n\nI'd upgrade if you can and like others have said, benchmark it. The `time` module is good and so is `scalene` if you want to run a profiler on it.",
        "score": 4,
        "date": "2025-04-27T17:58:17",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.006,
          "neutral": 0.068,
          "positive": 0.925
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.002,
          "fear": 0.0,
          "joy": 0.039,
          "neutral": 0.952,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "wingtales",
        "comment": "You should mainly care about the performance of the programs you use. I suggest you try running your code on both and compare. If you can’t tell the difference, then it’s fine to upgrade.",
        "score": 5,
        "date": "2025-04-27T08:46:26",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.126,
          "neutral": 0.57,
          "positive": 0.304
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.009,
          "disgust": 0.009,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.975,
          "sadness": 0.003,
          "surprise": 0.002
        }
      },
      {
        "user": "russellvt",
        "comment": "Have you tried profiling your code? That's probably your best answer/option, and one of the best reasons to use something like `pyenv` and various associated `venv` on your dev stacks.",
        "score": 3,
        "date": "2025-04-27T09:55:28",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.003,
          "neutral": 0.088,
          "positive": 0.908
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.003,
          "fear": 0.0,
          "joy": 0.014,
          "neutral": 0.975,
          "sadness": 0.0,
          "surprise": 0.003
        }
      },
      {
        "user": "Amazing_Upstairs",
        "comment": "I hear 3.14159265358979323846264338327950288419716939937510 is very good for math",
        "score": -2,
        "date": "2025-04-27T16:51:19",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.002,
          "neutral": 0.04,
          "positive": 0.958
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.001,
          "disgust": 0.001,
          "fear": 0.002,
          "joy": 0.107,
          "neutral": 0.883,
          "sadness": 0.001,
          "surprise": 0.005
        }
      },
      {
        "user": "Compux72",
        "comment": "Performance discussion about Python. Thats a joke right?",
        "score": -26,
        "date": "2025-04-27T11:31:00",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.318,
          "neutral": 0.542,
          "positive": 0.14
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.007,
          "neutral": 0.893,
          "sadness": 0.0,
          "surprise": 0.092
        }
      }
    ],
    "resumen_mt5": "The last bugfix release of Python 3.14 has been released. The BBC's weekly The Boss series profiles different users from around the world."
  },
  {
    "flair": "Discussion",
    "title": "Best framework to learn? Flask, Django, or Fast API",
    "author": "Icy_Government_8599",
    "date": "2025-04-30T10:18:37",
    "score": 82,
    "description": "**\"What is the quickest and easiest backend framework to learn for someone who is specifically focused on iOS app development, and  that integrates well with Firebase?**",
    "comments": [
      {
        "user": "ArabicLawrence",
        "comment": "Quickest and easiest: Flask or FastApi. But if you need a user model, you might prefer learning django for the long term. I don’t know Fast Api well enough, but for flask I recommend flask-admin and flask-security libraries rather than reinventing the wheel",
        "score": 75,
        "date": "2025-04-30T10:24:06",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.095,
          "neutral": 0.498,
          "positive": 0.407
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.993,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "i_dont_wanna_sign_in",
        "comment": "I know all three of these and if i had to stand up a full stack app tomorrow I'd just use Django to get it done quick. At this point in the game I'm only using Flask when a project already leveraged it, but not for anything new.\n\nFastAPI for pure API\nDjango for doing a full fledged app\n\nYou'll probably be learning the ORMs alongside both. That'll probably be SQLAlchemy for FastAPI/Flask, and will be Django's ORM. I find Django to be easier. But that's probably because i learned it first",
        "score": 46,
        "date": "2025-04-30T10:56:44",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.026,
          "neutral": 0.312,
          "positive": 0.662
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.0,
          "joy": 0.002,
          "neutral": 0.99,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "Shriukan33",
        "comment": "Django all the way, all day if you want to have user management, admin panel and crud done fast out of the box.\n\nDon't bother if you only intend it for like a couple of endpoints, but django is a great framework that has way more features than any of the other frameworks, it comes with its complexity though.",
        "score": 21,
        "date": "2025-04-30T11:56:15",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.011,
          "neutral": 0.074,
          "positive": 0.915
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.008,
          "fear": 0.0,
          "joy": 0.004,
          "neutral": 0.977,
          "sadness": 0.004,
          "surprise": 0.001
        }
      },
      {
        "user": "Augusto2012",
        "comment": "Quickest = FastAPI\n\nEasiest = Flask\n\nRobust and Professional = Django",
        "score": 9,
        "date": "2025-04-30T15:13:50",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.011,
          "neutral": 0.442,
          "positive": 0.547
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.001,
          "disgust": 0.002,
          "fear": 0.003,
          "joy": 0.01,
          "neutral": 0.981,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "kmierzej",
        "comment": "FastAPI, for it depends on Pydantic.",
        "score": 26,
        "date": "2025-04-30T10:43:26",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.047,
          "neutral": 0.858,
          "positive": 0.095
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.001,
          "neutral": 0.989,
          "sadness": 0.003,
          "surprise": 0.003
        }
      },
      {
        "user": "Astronos",
        "comment": "fastapi",
        "score": 16,
        "date": "2025-04-30T10:51:10",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.204,
          "neutral": 0.585,
          "positive": 0.211
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.0,
          "fear": 0.0,
          "joy": 0.002,
          "neutral": 0.986,
          "sadness": 0.002,
          "surprise": 0.006
        }
      },
      {
        "user": "j_hermann",
        "comment": "Litestar.",
        "score": 22,
        "date": "2025-04-30T10:30:39",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.18,
          "neutral": 0.664,
          "positive": 0.156
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.991,
          "sadness": 0.003,
          "surprise": 0.001
        }
      },
      {
        "user": "fiskfisk",
        "comment": "Either one is going to work fine, and either one is going to have certain specific things you're going to have to learn to use them. Efficiency from scratch is probably to be rather similar, given that they all have the same features - django just includes more of them in the standard library, while the other ones will either have external modules or things you add as you wish.",
        "score": 3,
        "date": "2025-04-30T10:40:07",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.037,
          "neutral": 0.436,
          "positive": 0.527
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.02,
          "disgust": 0.019,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.945,
          "sadness": 0.011,
          "surprise": 0.002
        }
      },
      {
        "user": "really_not_unreal",
        "comment": "* Quickest: probably FastAPI. I haven't used it much myself but it's probably the quickest to write with. If you mean quickest in terms of performance, you probably shouldn't be using Python.\n* Easiest: doesn't get much easier than Flask. I teach Flask to students with less than 2 months of programming experience and it makes sense to them.\n\nThat being said idk much about Firebase so that might change things a little.",
        "score": 6,
        "date": "2025-04-30T10:42:23",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.177,
          "neutral": 0.433,
          "positive": 0.39
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.001,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.011,
          "neutral": 0.981,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "jlw_4049",
        "comment": "If you like flask but want pure async check out Quart",
        "score": 2,
        "date": "2025-04-30T14:11:35",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.04,
          "neutral": 0.792,
          "positive": 0.168
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.991,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "shadowdance55",
        "comment": "Starlette",
        "score": 3,
        "date": "2025-04-30T11:58:47",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.16,
          "neutral": 0.63,
          "positive": 0.211
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.0,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.989,
          "sadness": 0.003,
          "surprise": 0.004
        }
      },
      {
        "user": "xAragon_",
        "comment": "Litestar",
        "score": 5,
        "date": "2025-04-30T10:22:13",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.212,
          "neutral": 0.578,
          "positive": 0.21
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.992,
          "sadness": 0.003,
          "surprise": 0.002
        }
      },
      {
        "user": "dicklesworth",
        "comment": "Definitely FastAPI. And you should also learn and use SQLmodel by the same author with SQLite. And use Uvicorn to serve on some port like 8008 and reverse proxy to Nginx.",
        "score": 2,
        "date": "2025-04-30T13:19:02",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.041,
          "neutral": 0.68,
          "positive": 0.279
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.002,
          "fear": 0.0,
          "joy": 0.003,
          "neutral": 0.987,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "AtmosphereRich4021",
        "comment": "Fastapi if you are building API and use JS or others in frontend.....  Django if you are going full-stack...... Btw I chose fast API and never regretted my decision.",
        "score": 1,
        "date": "2025-04-30T14:37:31",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.017,
          "neutral": 0.255,
          "positive": 0.729
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.014,
          "disgust": 0.007,
          "fear": 0.008,
          "joy": 0.006,
          "neutral": 0.79,
          "sadness": 0.173,
          "surprise": 0.002
        }
      },
      {
        "user": "No_Pomegranate7508",
        "comment": "Flask.\n\nI use this template: [https://github.com/habedi/template-web-app-flask](https://github.com/habedi/template-web-app-flask)",
        "score": 1,
        "date": "2025-04-30T14:43:59",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.062,
          "neutral": 0.871,
          "positive": 0.067
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.013,
          "neutral": 0.977,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "ishammohamed",
        "comment": "Just curious as you have mentioned firebase, I assume your app already connects with firebase so why do you require a different backend?",
        "score": 1,
        "date": "2025-04-30T16:25:16",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.085,
          "neutral": 0.834,
          "positive": 0.08
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.003,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.894,
          "sadness": 0.002,
          "surprise": 0.095
        }
      },
      {
        "user": "EmptySoulCanister",
        "comment": "Django if you want something that might get you a job. \n\nFastAPI for the best experience.",
        "score": 1,
        "date": "2025-04-30T17:17:09",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.012,
          "neutral": 0.302,
          "positive": 0.686
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.992,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "s_basu",
        "comment": "Learn Flask to learn wsgi. Know the pitfalls of wsgi, learn FastApi, learn asgi. Know the pitfalls of using barebone libraries. Learn django, get frustrated with its verbosity. Come back to Flask. Rinse and repeat.",
        "score": 1,
        "date": "2025-04-30T17:45:11",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.508,
          "neutral": 0.414,
          "positive": 0.078
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.03,
          "disgust": 0.003,
          "fear": 0.002,
          "joy": 0.004,
          "neutral": 0.958,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "yost28",
        "comment": "I'd recommend fast-api, its the shiny new equivalent of flask. Less familiar with Django but I believe its a more used as a full stack (frontend and backend). In my experience for frontend you probably want a JavaScript framework like React or React native for mobile.\n\nIf you really want to use firebase and ios you might look at ios specific frameworks, Flutter, Swift, React Native. Imo the python frameworks are not good on mobile. Django might have some tools for mobile though, unsure on that one.",
        "score": 1,
        "date": "2025-04-30T18:51:24",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.115,
          "neutral": 0.548,
          "positive": 0.337
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.002,
          "joy": 0.001,
          "neutral": 0.991,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "aashayamballi",
        "comment": "If someone’s choosing between Django, FastAPI, or Flask, I’d personally go with Django — especially for big monolithic apps. But even for smaller projects, it still holds up really well.\n\nOnce you get comfortable with how Django is structured — apps, models, views, serializers, class-based views, mixins — it really starts to feel powerful. And tools like Django Rest Framework or django-filter make a lot more sense once you understand the Django philosophy. They follow the same patterns, so if you get that, you can extend or build your own stuff cleanly — which is super helpful as the project grows.\n\nOne thing I really appreciate is how solid the ORM and migration system is. You don’t have to manually manage schema changes or deal with raw SQL unless you want to — it’s just smooth. Also, async support is maturing well in Django now, so you're not missing out on that front either.\n\nThe ecosystem is huge, the community is super helpful, and there are packages for pretty much anything. And if you like the FastAPI-style APIs (type hints, minimal boilerplate), check out Django Ninja — it gives you that clean style while staying within the Django world.",
        "score": 1,
        "date": "2025-04-30T19:34:40",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.003,
          "neutral": 0.042,
          "positive": 0.955
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.023,
          "neutral": 0.97,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "akshaytandroid",
        "comment": "I am an android engineer. I learned python by starting with FASTAPI and now I have a backend setup pretty nice.",
        "score": 1,
        "date": "2025-04-30T20:36:05",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.002,
          "neutral": 0.029,
          "positive": 0.969
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.008,
          "neutral": 0.986,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "mpvanwinkle",
        "comment": "I prefer Starlette, it’s fastapi but without forcing you into annotation hell and gives you flexibility to use msgspec instead of pydantic. there’s nothing wrong with pydantic but msgspec is a little lighter and doesn’t have a dependency on rust. \n\nI wouldn’t invest too much into any one framework though. If the goal is learning, learn how to build your own http server",
        "score": 1,
        "date": "2025-05-01T02:06:55",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.088,
          "neutral": 0.399,
          "positive": 0.512
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.008,
          "disgust": 0.005,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.982,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "wilson_wilson_wilson",
        "comment": "if you're focused on ios i guess why hold on to python?\n\nEDIT: this is from someone who would die for FastAPI in a heartbeat. My favorite framework hands down but that's me and my flow.",
        "score": 1,
        "date": "2025-05-01T02:13:24",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.056,
          "neutral": 0.249,
          "positive": 0.695
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.986,
          "sadness": 0.003,
          "surprise": 0.002
        }
      },
      {
        "user": "Miserable_Ear3789",
        "comment": "MicroPie is super easy to learn! Check out [https://patx.github.io/micropie](https://patx.github.io/micropie)\n\nIts ASGI and is super simple. Check it out. I wrote and maintain it.\n\n  \nFlask is WSGI which we are somewhat transitioning away from (hence fastapi's (also asgi) newfound popularity)",
        "score": 1,
        "date": "2025-05-01T05:06:59",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.003,
          "neutral": 0.07,
          "positive": 0.927
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.008,
          "disgust": 0.001,
          "fear": 0.002,
          "joy": 0.104,
          "neutral": 0.879,
          "sadness": 0.0,
          "surprise": 0.006
        }
      },
      {
        "user": "Nanooc523",
        "comment": "“Best”",
        "score": 1,
        "date": "2025-05-01T08:09:30",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.119,
          "neutral": 0.607,
          "positive": 0.274
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.004,
          "fear": 0.001,
          "joy": 0.019,
          "neutral": 0.964,
          "sadness": 0.001,
          "surprise": 0.009
        }
      },
      {
        "user": "bambuk4",
        "comment": "Fastapi allows you to apply hexagonal design very easily. I guess that Flask too. Django on the other hand is very coupled. The worst thing I don like is having your core entities tight to the framework. \n\nIf the project is not big you can go for Django but in other cases my bet is Fastapi. It's a framework focused on one task and only one, rest API. Rest of the task you can use other focused libraries.\n\nIt has been a long time since I didn't use Django, do you still need DRF to decouple the frontend?",
        "score": 1,
        "date": "2025-05-01T08:24:14",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.495,
          "neutral": 0.399,
          "positive": 0.106
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.012,
          "disgust": 0.038,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.943,
          "sadness": 0.004,
          "surprise": 0.001
        }
      },
      {
        "user": "durable-racoon",
        "comment": "**go for fastapi plus pydantic** \\- I assume you just need API endpoints for your iOS app.\n\nalso consider firebase cloud functions or node.js as alternatives for your project.",
        "score": 1,
        "date": "2025-04-30T12:09:27",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.041,
          "neutral": 0.712,
          "positive": 0.247
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.988,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "justrandomqwer",
        "comment": "It depends. If you need a bunch of CRUD endpoints (for your mobile app, native app, single-page app, etc), then FastAPI will be the perfect choice. It’s well-designed, well-documented, relatively fast, and has a huge community. Both sync and async paradigms are supported (but you should pick the one early). Learning curve is short, you may start your backend just after a few tutorials. On the other hand, if you need a fully functional web app (with multi-page frontend, styles, DB, etc.), then the better option will be Django or Flask. Django designed with the «batteries included» approach, Flask is more minimalistic.",
        "score": 1,
        "date": "2025-04-30T13:23:25",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.009,
          "neutral": 0.148,
          "positive": 0.843
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.991,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "usrname--",
        "comment": "FastAPI. \nDjango has too much abstraction and doesn’t allow using good practices like separation of concerns etc. Having to put business logic in serializers or models is awful.",
        "score": -2,
        "date": "2025-04-30T12:18:12",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.869,
          "neutral": 0.116,
          "positive": 0.015
        },
        "emotion": "disgust",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.884,
          "fear": 0.015,
          "joy": 0.001,
          "neutral": 0.064,
          "sadness": 0.029,
          "surprise": 0.003
        }
      },
      {
        "user": "cnydox",
        "comment": "Fastapi",
        "score": 0,
        "date": "2025-04-30T10:52:23",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.199,
          "neutral": 0.576,
          "positive": 0.225
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.986,
          "sadness": 0.001,
          "surprise": 0.007
        }
      },
      {
        "user": "Relevant-Strength-53",
        "comment": "Loved using fastapi",
        "score": 0,
        "date": "2025-04-30T11:38:46",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.003,
          "neutral": 0.031,
          "positive": 0.966
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.069,
          "neutral": 0.924,
          "sadness": 0.003,
          "surprise": 0.001
        }
      },
      {
        "user": "ReserveGrader",
        "comment": "In my experience, the FastAPI documentation is really good. Also, both Flask and FastAPI will use the \\`firebase-admin\\` and/or \\`pyrebase\\` libraries so the experience will be pretty similar on that side.",
        "score": 0,
        "date": "2025-04-30T11:39:11",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.002,
          "neutral": 0.029,
          "positive": 0.968
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.004,
          "neutral": 0.988,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "RiffnShred",
        "comment": "Yes",
        "score": 0,
        "date": "2025-04-30T12:41:49",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.126,
          "neutral": 0.473,
          "positive": 0.401
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.001,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.006,
          "neutral": 0.988,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "anonymous",
        "comment": "[deleted]",
        "score": 0,
        "date": "2025-04-30T12:58:50",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.275,
          "neutral": 0.652,
          "positive": 0.072
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.004,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.982,
          "sadness": 0.001,
          "surprise": 0.01
        }
      },
      {
        "user": "selmon-fan01",
        "comment": "I usually decide by\nSmall poc or fire and forget code - flask, fastapi\nFull featured web app with admin interface and orm support inbuilt, strict structural setup required - Django\nHigh performance inbuilt async REST API, AI ML usecases - Fastapi",
        "score": 0,
        "date": "2025-04-30T13:44:19",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.016,
          "neutral": 0.636,
          "positive": 0.348
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.013,
          "neutral": 0.98,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "WJMazepas",
        "comment": "Honestly, FastAPI. It's great for writing a pure API, can integrate well with Firebase, and you get typing in the requests, which helps a lot",
        "score": -1,
        "date": "2025-04-30T12:01:54",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.002,
          "neutral": 0.025,
          "positive": 0.973
        },
        "emotion": "joy",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.604,
          "neutral": 0.388,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "drizzle_4_2_0",
        "comment": "If you want to go fully API, I'd suggest FastAPI, since you can customize the whole application based on your preferences and it is easier. \n\nBut if you're looking for a full stack solution, I'd either go with Flask or Django. \n\nDjango gets you faster to the point, but Flask will make you understand those things better since you need to develop most of the stuff on your own.",
        "score": -1,
        "date": "2025-04-30T12:13:11",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.023,
          "neutral": 0.327,
          "positive": 0.649
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.004,
          "fear": 0.002,
          "joy": 0.001,
          "neutral": 0.984,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "Last_Difference9410",
        "comment": "You might want to check out lihil, it has built in auth system that let you set up oauth compatible auth system within a few lines.",
        "score": -4,
        "date": "2025-04-30T10:40:17",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.005,
          "neutral": 0.553,
          "positive": 0.442
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.01,
          "neutral": 0.984,
          "sadness": 0.001,
          "surprise": 0.002
        }
      }
    ],
    "resumen_mt5": "The BBC's weekly The Boss series profiles different developers from around the world. This week we speak to us about the best frameworks to learn."
  },
  {
    "flair": "Resource",
    "title": "My own programming language",
    "author": "iloveduckstoomuch",
    "date": "2025-04-25T15:57:10",
    "score": 50,
    "description": "I made my own interpreted programming language in Python.\n\nIts called Pear, and i somehow got it to support library's that are easy to create.\n\nYou can check it out here: [Pear](https://github.com/pearlanguage/Pear).\n\nI desperately need feedback, so please go check it out.",
    "comments": [
      {
        "user": "B3d3vtvng69",
        "comment": "Some tips:\n\n- Separate your logic! Don’t put everything in one function, create seperate functions (or classes if you’re planning on extending your language) for getting the next token, deciding on what to do with the next token and actually executing instructions.\n\n- If you want to extend your language: create seperate classes for tokenizing, parsing the programm (checking syntax etc.) and constructing an abstract syntax tree and the actual interpreter that just walks that abstract syntax tree, executing it in the process. \n\nIf you want to take a look at a bigger Compiler Project, you can check out my Python to C++ Compiler pytocpp [here](https://www.github.com/b3d3vtvng/pytocpp) \nAlso hit me up if you need any advice.\n\nEdit: Spelling",
        "score": 45,
        "date": "2025-04-25T16:39:18",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.075,
          "neutral": 0.723,
          "positive": 0.202
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.02,
          "disgust": 0.011,
          "fear": 0.004,
          "joy": 0.004,
          "neutral": 0.959,
          "sadness": 0.001,
          "surprise": 0.001
        }
      },
      {
        "user": "robobrobro",
        "comment": "Why is it called Pear?",
        "score": 6,
        "date": "2025-04-25T18:52:50",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.37,
          "neutral": 0.603,
          "positive": 0.027
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.002,
          "fear": 0.002,
          "joy": 0.001,
          "neutral": 0.644,
          "sadness": 0.001,
          "surprise": 0.347
        }
      },
      {
        "user": "DevSynth",
        "comment": "Not so much a programming language, moreso a turing machine",
        "score": 18,
        "date": "2025-04-25T17:00:06",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.417,
          "neutral": 0.537,
          "positive": 0.047
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.003,
          "fear": 0.0,
          "joy": 0.001,
          "neutral": 0.988,
          "sadness": 0.004,
          "surprise": 0.001
        }
      },
      {
        "user": "100721",
        "comment": "I’d recommend doing a chip8 emulator as the next step to this r/emudev",
        "score": 2,
        "date": "2025-04-25T19:14:00",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.003,
          "neutral": 0.33,
          "positive": 0.666
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.991,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "bpg2001bpg",
        "comment": "Have you considered using Pear to write a new programming language? You could call it 'Pie.'",
        "score": 2,
        "date": "2025-04-26T17:09:06",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.012,
          "neutral": 0.83,
          "positive": 0.158
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.007,
          "fear": 0.002,
          "joy": 0.011,
          "neutral": 0.97,
          "sadness": 0.001,
          "surprise": 0.003
        }
      },
      {
        "user": "Salamandar3500",
        "comment": "Shebangs ! That way you can just run \n\n./myscript.pr",
        "score": 1,
        "date": "2025-04-25T17:54:15",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.062,
          "neutral": 0.697,
          "positive": 0.241
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.012,
          "disgust": 0.002,
          "fear": 0.004,
          "joy": 0.188,
          "neutral": 0.785,
          "sadness": 0.001,
          "surprise": 0.009
        }
      },
      {
        "user": "timwaaagh",
        "comment": "Perhaps try to cythonize it for performance.",
        "score": 1,
        "date": "2025-04-26T08:09:01",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.043,
          "neutral": 0.877,
          "positive": 0.08
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.005,
          "disgust": 0.003,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.985,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "bDrwx",
        "comment": "Oh, thank you very much. I am looking for a simple project to learn. Yours looks interesting. Can i help you?",
        "score": 1,
        "date": "2025-04-26T08:29:57",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.001,
          "neutral": 0.016,
          "positive": 0.982
        },
        "emotion": "joy",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.0,
          "fear": 0.001,
          "joy": 0.87,
          "neutral": 0.123,
          "sadness": 0.001,
          "surprise": 0.003
        }
      },
      {
        "user": "LardPi",
        "comment": "I think you should try to solve some problems with your language to find it's limitations, and also flesh out the library. What are you trying to learn here? I would encourage you to turn this into a compiler as I think you would learn a lot from it. Also you could add a bit more syntax (infix operations for example) and learn more about parsers.",
        "score": 1,
        "date": "2025-04-27T01:02:45",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.04,
          "neutral": 0.489,
          "positive": 0.471
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.009,
          "disgust": 0.009,
          "fear": 0.001,
          "joy": 0.006,
          "neutral": 0.972,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "amyrasheldon",
        "comment": "[ R vs Python in Machine Learning](https://posts.gle/d3WupA)",
        "score": 1,
        "date": "2025-04-28T09:38:59",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.081,
          "neutral": 0.855,
          "positive": 0.064
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.988,
          "sadness": 0.001,
          "surprise": 0.004
        }
      },
      {
        "user": "Reasonable-Ladder300",
        "comment": "What is the exact purpose or benefit over using an interpreted language like python directly?\n\nNice side project but it doesn’t seem to have any real world use case or benefit.",
        "score": -7,
        "date": "2025-04-25T16:15:59",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.601,
          "neutral": 0.358,
          "positive": 0.042
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.022,
          "disgust": 0.015,
          "fear": 0.002,
          "joy": 0.001,
          "neutral": 0.83,
          "sadness": 0.004,
          "surprise": 0.128
        }
      },
      {
        "user": "Jaguar_AI",
        "comment": "subbing.",
        "score": 0,
        "date": "2025-04-26T04:53:42",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.35,
          "neutral": 0.563,
          "positive": 0.088
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.001,
          "disgust": 0.007,
          "fear": 0.001,
          "joy": 0.003,
          "neutral": 0.984,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "prpetrator",
        "comment": "whyd you choose python",
        "score": 0,
        "date": "2025-04-27T18:52:16",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.241,
          "neutral": 0.715,
          "positive": 0.045
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.0,
          "fear": 0.001,
          "joy": 0.003,
          "neutral": 0.989,
          "sadness": 0.001,
          "surprise": 0.004
        }
      }
    ],
    "resumen_mt5": "This is a full transcript of how I developed programming language in Python."
  },
  {
    "flair": "Showcase",
    "title": "CyCompile: Democratizing Performance — Easy Function-Level Optimization with Cython",
    "author": "Ranuja01",
    "date": "2025-04-28T17:01:33",
    "score": 48,
    "description": "Hi everyone!\n\nI’m excited to share a new project I've been working on: **CyCompile,** a Python package that makes function-level optimization with Cython simpler and more accessible for everyone. **Democratizing Performance** is at the heart of **CyCompile**, allowing developers of all skill levels to easily enhance their Python code without needing to become Cython experts!\n\n# Motivation\n\nAs a Python developer, I’ve often encountered the frustration of dealing with Python’s inherent performance limitations. When working with resource-intensive tasks or performance-critical applications, Python can feel slow and inefficient. While Cython can provide significant performance improvements, optimizing functions with it can be a daunting task. It requires understanding low-level C concepts, manually configuring the setup, and fine-tuning code for maximum efficiency.\n\nTo solve this problem, I created **CyCompile**, which breaks down the barriers to Cython usage and provides a simple, no-fuss way for developers to optimize their code. With just a decorator, Python developers can leverage the power of Cython’s compiled code, boosting performance without needing to dive into its complexities. Whether you’re new to Cython or just want a quick performance boost, **CyCompile** makes function-level optimization easy and accessible for everyone.\n\n# Target Audience\n\n**CyCompile** is for **any Python developer** who wants to optimize their code, regardless of their experience level. Whether you're a beginner or an expert, **CyCompile** allows you to boost performance with minimal setup and effort. It’s especially useful in environments like **notebooks**, **rapid prototyping**, or **production systems**, where precise performance improvements are needed without impacting the rest of the codebase.\n\nAt its core, **CyCompile** bridges the gap between **Python’s elegance** and **C-level speed**, making it accessible to everyone. You don’t need to be a compiler expert to take advantage of Cython’s powerful performance benefits, **CyCompile** empowers **anyone** to optimize their functions easily and efficiently.\n\n# Comparison\n\nUnlike Numba’s `njit`, which often implicitly compiles entire dependency chains and helper functions, or Cython’s `cython.compile()`, which is generally applied to full modules or .pyx files, **CyCompile's** `cycompile()` is specifically designed for **targeted**, **function-by-function** performance upgrades. With **CyCompile**, you stay in control: only the functions you explicitly decorate get compiled, leaving the rest of your code untouched. This makes it ideal for speeding up **critical hotspots** without overcomplicating your project structure.\n\nOn top of this, **CyCompile's** `cycompile()` decorator offers several distinct advantages over Cython's `cython.compile()` decorator. It supports recursive functions natively, eliminating the need for special workarounds. Additionally, it integrates seamlessly with static Python type annotations, allowing you to annotate your code without requiring Cython-specific syntax or modifications. For more advanced users, **CyCompile** provides fine-tuned control over compilation parameters, such as Cython directives and C compiler flags, offering greater flexibility and customizability. Furthermore, its simple and customizable approach can, in some cases, outperform `cython.compile()` due to the precision and control it offers. Unlike Cython, **CyCompile** also provides a mechanism for clearing the cache, helping you manage file clutter and keep your project clean.\n\n# Key Features\n\n* **Non-invasive design** — requires no changes to your existing project structure or imports, just add a decorator.\n* **Understands standard Python type hints** — avoiding the need for Cython-specific rewrites.\n* **Handles recursive functions** — overcoming a common limitation in traditional function-level compilation tools.\n* **Supports user-defined objects** and custom logic more gracefully than many static compilers.\n* **Offers fine-grained control** over Cython directives and compiler flags for advanced users.\n* **Intelligent source-based caching** — automatically avoids unnecessary recompilation by detecting source changes.\n* **Includes a manual cache cleanup option** — giving developers control over the binary cache when desired.\n\n# Documentation & Source Code\n\nFull installation steps and usage instructions are available on both the [README](https://github.com/Ranuja01/cycompile/blob/main/README.md) and [PyPI page](https://pypi.org/project/cycompile/). **I also wrote a detailed Medium article covering use cases** (r/Python rules don't allow Medium links, but you can find it linked in the README!). \n\nFor those interested in how the implementation works under the hood or who want to contribute, the full source is available on [GitHub](https://github.com/Ranuja01/cycompile). **CyCompile** is actively maintained, and any contributions or suggestions for improvement are welcome!\n\n# Conclusion\n\nI hope this post has given you a good understanding of what **CyCompile** can do for your Python code. I encourage you to try it out, experiment with different configurations, and see how it can speed up your critical functions. You can find installation instructions and [example code](https://github.com/Ranuja01/cycompile/tree/main/examples) on GitHub to get started.\n\n**CyCompile** makes it easy to optimize specific parts of your code without major refactoring, and its flexibility means you can customize exactly what gets accelerated. That said, given the large variety of potential use cases, it’s difficult to anticipate every edge case or library that may not work as expected. However, I look forward to seeing how the community uses this tool and how it can evolve from there.\n\nIf you try it out, feel free to share your thoughts or suggestions in the comments, I’d love to hear from you!\n\nHappy compiling!\n\n",
    "comments": [
      {
        "user": "jmreagle",
        "comment": "Benchmarks?",
        "score": 3,
        "date": "2025-04-29T00:30:09",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.159,
          "neutral": 0.782,
          "positive": 0.059
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.002,
          "joy": 0.001,
          "neutral": 0.856,
          "sadness": 0.001,
          "surprise": 0.136
        }
      },
      {
        "user": "condalf97",
        "comment": "Very nice",
        "score": 3,
        "date": "2025-04-28T20:24:45",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.005,
          "neutral": 0.038,
          "positive": 0.957
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.001,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.354,
          "neutral": 0.635,
          "sadness": 0.003,
          "surprise": 0.003
        }
      },
      {
        "user": "KingLai5",
        "comment": "Tried it myself, this is very useful",
        "score": 3,
        "date": "2025-04-28T21:28:42",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.002,
          "neutral": 0.034,
          "positive": 0.963
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.094,
          "neutral": 0.894,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "ichunddu9",
        "comment": "Benchmarks vs Numba, please.",
        "score": 3,
        "date": "2025-04-29T00:48:35",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.047,
          "neutral": 0.859,
          "positive": 0.095
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.019,
          "fear": 0.012,
          "joy": 0.001,
          "neutral": 0.957,
          "sadness": 0.007,
          "surprise": 0.002
        }
      },
      {
        "user": "opuntia_conflict",
        "comment": "How does it compare to Pypy (the One True Python implementation)?",
        "score": 2,
        "date": "2025-04-29T04:20:52",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.053,
          "neutral": 0.867,
          "positive": 0.08
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.004,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.002,
          "neutral": 0.948,
          "sadness": 0.001,
          "surprise": 0.043
        }
      },
      {
        "user": "engineerofsoftware",
        "comment": "So I lose the granularity and performance of Cython for something that massively increases the latency of my function, and it also shits all over my filesystem with its cache, simply because I didn’t want to use my IDE settings to hide the compiled binaries? Fastest way to get my PR rejected.",
        "score": -1,
        "date": "2025-04-30T19:27:02",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.89,
          "neutral": 0.098,
          "positive": 0.011
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.108,
          "disgust": 0.039,
          "fear": 0.002,
          "joy": 0.003,
          "neutral": 0.762,
          "sadness": 0.006,
          "surprise": 0.079
        }
      }
    ],
    "resumen_mt5": "This is a full transcript of the latest Python project."
  },
  {
    "flair": "Resource",
    "title": "I built a Python framework for testing, stealth, and CAPTCHA-bypass",
    "author": "SeleniumBase",
    "date": "2025-04-24T16:30:28",
    "score": 39,
    "description": "Regular Selenium didn't have all the features I needed (like testing and stealth), so I built a framework around it.\n\nGitHub: [https://github.com/seleniumbase/SeleniumBase](https://github.com/seleniumbase/SeleniumBase)\n\nI added two different stealth modes along the way:\n\n* [UC Mode](https://github.com/seleniumbase/SeleniumBase/blob/master/help_docs/uc_mode.md) \\- (which works by modifying Chromedriver) - First released in 2022.\n* [CDP Mode](https://github.com/seleniumbase/SeleniumBase/blob/master/examples/cdp_mode/ReadMe.md) \\- (which works by using the CDP API) - First released in 2024.\n\nThe testing components have been around for much longer than that, as the framework integrates with `pytest` as a plugin. (Most examples in the [SeleniumBase/examples/](https://github.com/seleniumbase/SeleniumBase/tree/master/examples) folder still run with `pytest`, although many of the newer examples for stealth run with raw `python`.)\n\nBoth async and non-async formats are supported. ([See the full list](https://github.com/seleniumbase/SeleniumBase/blob/master/help_docs/syntax_formats.md))\n\nA few stealth examples:\n\n1: Google Search - (Avoids reCAPTCHA) - Uses regular UC Mode.\n\n    from seleniumbase import SB\n    \n    with SB(test=True, uc=True) as sb:\n        sb.open(\"https://google.com/ncr\")\n        sb.type('[title=\"Search\"]', \"SeleniumBase GitHub page\\n\")\n        sb.click('[href*=\"github.com/seleniumbase/\"]')\n        sb.save_screenshot_to_logs()  # ./latest_logs/\n        print(sb.get_page_title())\n\n2: Indeed Search - (Avoids Cloudflare) - Uses CDP Mode from UC Mode.\n\n    from seleniumbase import SB\n    \n    with SB(uc=True, test=True) as sb:\n        url = \"https://www.indeed.com/companies/search\"\n        sb.activate_cdp_mode(url)\n        sb.sleep(1)\n        sb.uc_gui_click_captcha()\n        sb.sleep(2)\n        company = \"NASA Jet Propulsion Laboratory\"\n        sb.press_keys('input[data-testid=\"company-search-box\"]', company)\n        sb.click('button[type=\"submit\"]')\n        sb.click('a:contains(\"%s\")' % company)\n        sb.sleep(2)\n        print(sb.get_text('[data-testid=\"AboutSection-section\"]'))\n\n3: Glassdoor - (Avoids Cloudflare) - Uses CDP Mode from UC Mode.\n\n    from seleniumbase import SB\n    \n    with SB(uc=True, test=True) as sb:\n        url = \"https://www.glassdoor.com/Reviews/index.htm\"\n        sb.activate_cdp_mode(url)\n        sb.sleep(1)\n        sb.uc_gui_click_captcha()\n        sb.sleep(2)\n\nMore examples can be found from [the GitHub page](https://github.com/seleniumbase/SeleniumBase). (Stars are welcome! ⭐)\n\nThere's also a pure CDP stealth format that doesn't use Selenium at all (by going directly through the CDP API). [Example of that](https://github.com/seleniumbase/SeleniumBase/blob/master/examples/cdp_mode/raw_cdp.py).",
    "comments": [
      {
        "user": "ph34r",
        "comment": "Thanks for what you do! I use selenium base for various home automation integrations that aren't officially supported.",
        "score": 4,
        "date": "2025-04-25T01:31:44",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.019,
          "neutral": 0.164,
          "positive": 0.818
        },
        "emotion": "joy",
        "emotion_probs": {
          "anger": 0.012,
          "disgust": 0.001,
          "fear": 0.001,
          "joy": 0.843,
          "neutral": 0.133,
          "sadness": 0.001,
          "surprise": 0.01
        }
      },
      {
        "user": "Muhznit",
        "comment": "Have you considered that there is a reason why CAPTCHAs exist in the first place and that you're now enabling those reasons to do what people wanted to prevent?\n\n\nE.g. Fake reviews on cloud flare, tons of unqualified applicants in indeed, manipulation of search popularity in google...",
        "score": -14,
        "date": "2025-04-24T16:37:49",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.756,
          "neutral": 0.23,
          "positive": 0.014
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.301,
          "disgust": 0.074,
          "fear": 0.006,
          "joy": 0.008,
          "neutral": 0.515,
          "sadness": 0.016,
          "surprise": 0.081
        }
      }
    ],
    "resumen_mt5": "When I started developing a stealth framework for Google's Selenium, I was asked to explain why."
  },
  {
    "flair": "Discussion",
    "title": "Signal-based State Management in Python: How I Brought Angular's Best Feature to Backend Code",
    "author": "loyoan",
    "date": "2025-04-25T13:22:35",
    "score": 38,
    "description": "Hey Pythonistas,\n\nI wanted to share a library I've been working on called [reaktiv](https://github.com/buiapp/reaktiv) that brings reactive programming to Python with first-class async support. I've noticed there's a misconception that reactive programming is only useful for UI development, but it's actually incredibly powerful for backend systems too.\n\n# What is reaktiv?\n\nReaktiv is a lightweight, zero-dependency library that brings a reactive programming model to Python, inspired by Angular's signals. It provides three core primitives:\n\n* **Signals**: Store values that notify dependents when changed\n* **Computed Signals**: Derive values that automatically update when dependencies change\n* **Effects**: Execute side effects when signals or computed values change\n\n# This isn't just another pub/sub library\n\nA common misconception is that reactive libraries are just fancy pub/sub systems. Here's why reaktiv is fundamentally different:\n\n|Pub/Sub Systems|Reaktiv|\n|:-|:-|\n|Message delivery between components|Automatic state dependency tracking|\n|Point-to-point or broadcast messaging|Fine-grained computation graphs|\n|Manual subscription management|Automatic dependency detection|\n|Focus on message transport|Focus on state derivation|\n|Stateless by design|Intentional state management|\n\n# \"But my backend is stateless!\"\n\nEven in \"stateless\" services, ephemeral state exists during request handling:\n\n* Configuration management\n* Request context propagation\n* In-memory caching\n* Rate limiting and circuit breaking\n* Feature flag evaluation\n* Connection pooling\n* Metrics collection\n\n# Real backend use cases I've implemented with reaktiv\n\n# 1. Intelligent Cache Management\n\nDerived caches that automatically invalidate when source data changes - no more manual cache invalidation logic scattered throughout your codebase.\n\n# 2. Adaptive Rate Limiting & Circuit Breaking\n\nDynamic rate limits that adjust based on observed traffic patterns with circuit breakers that automatically open/close based on error rates.\n\n# 3. Multi-Layer Configuration Management\n\nConfiguration from multiple sources (global, service, instance) that automatically merges with the correct precedence throughout your application.\n\n# 4. Real-Time System Monitoring\n\nA system where metrics flow in, derived health indicators automatically update, and alerting happens without any explicit wiring.\n\n# Benefits for backend development\n\n1. **Eliminates manual dependency tracking**: No more forgotten update logic when state changes\n2. **Prevents state synchronization bugs**: Updates happen automatically and consistently\n3. **Improves performance**: Only affected computations are recalculated\n4. **Reduces cognitive load**: Declare relationships once, not throughout your codebase\n5. **Simplifies testing**: Clean separation of state, derivation, and effects\n\n# How Dependency Tracking Works\n\nOne of reaktiv's most powerful features is **automatic dependency tracking**. Here's how it works:\n\n**1. Automatic Detection**: When you access a signal within a computed value or effect, reaktiv automatically registers it as a dependency—no manual subscription needed.\n\n**2. Fine-grained Dependency Graph**: Reaktiv builds a precise dependency graph during execution, tracking exactly which computations depend on which signals.\n\n    # These dependencies are automatically tracked:\n    total = computed(lambda: price() * (1 + tax_rate()))\n\n**3. Surgical Updates**: When a signal changes, only the affected parts of your computation graph are recalculated—not everything.\n\n**4. Dynamic Dependencies**: The dependency graph updates automatically if your data access patterns change based on conditions:\n\n    def get_visible_items():\n        items = all_items()\n        if show_archived():\n            return items  # Only depends on all_items\n        else:\n            return [i for i in items if not i.archived]  # Depends on both signals\n\n**5. Batching and Scheduling**: Updates can be batched to prevent cascading recalculations, and effects run on the next event loop tick for better performance.\n\nThis automatic tracking means you define your data relationships once, declaratively, instead of manually wiring up change handlers throughout your codebase.\n\n# Example: Health Monitoring System\n\n    from reaktiv import signal, computed, effect\n    \n    # Core state signals\n    server_metrics = signal({})  # server_id -> {cpu, memory, disk, last_seen}\n    alert_thresholds = signal({\"cpu\": 80, \"memory\": 90, \"disk\": 95})\n    maintenance_mode = signal({})  # server_id -> bool\n    \n    # Derived state automatically updates when dependencies change\n    health_status = computed(lambda: {\n        server_id: (\n            \"maintenance\" if maintenance_mode().get(server_id, False) else\n            \"offline\" if time.time() - metrics[\"last_seen\"] > 60 else\n            \"alert\" if (\n                metrics[\"cpu\"] > alert_thresholds()[\"cpu\"] or\n                metrics[\"memory\"] > alert_thresholds()[\"memory\"] or\n                metrics[\"disk\"] > alert_thresholds()[\"disk\"]\n            ) else \n            \"healthy\"\n        )\n        for server_id, metrics in server_metrics().items()\n    })\n    \n    # Effect triggers when health status changes\n    dashboard_effect = effect(lambda: \n        print(f\"ALERT: {[s for s, status in health_status().items() if status == 'alert']}\")\n    )\n\nThe beauty here is that when any metric comes in, thresholds change, or servers go into maintenance mode, everything updates automatically without manual orchestration.\n\n# Should you try it?\n\nIf you've ever:\n\n* Written manual logic to keep derived state in sync\n* Found bugs because a calculation wasn't triggered when source data changed\n* Built complex observer patterns or event systems\n* Struggled with keeping caches fresh\n\nThen reaktiv might make your backend code simpler, more maintainable, and less buggy.\n\nLet me know what you think! Does anyone else use reactive patterns in backend code?\n\n[Check it out on GitHub](https://github.com/buiapp/reaktiv) | [PyPI](https://pypi.org/project/reaktiv/)",
    "comments": [
      {
        "user": "teerre",
        "comment": "If you research battle tested backend frameworks in other languages you'll see something like this is quite rare. There's a reason for that. All this global state and magic make it harder to reason about the program. Backends tend to prefer stability",
        "score": 15,
        "date": "2025-04-26T15:58:51",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.365,
          "neutral": 0.538,
          "positive": 0.097
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.003,
          "fear": 0.0,
          "joy": 0.001,
          "neutral": 0.988,
          "sadness": 0.002,
          "surprise": 0.003
        }
      },
      {
        "user": "KvotheQuote",
        "comment": "I'd love to use it if the overhead is small enough. Is it fully implemented in Python? How much longer can I expect 1m updates to take in the simplest scenario?",
        "score": 1,
        "date": "2025-04-26T15:47:56",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.051,
          "neutral": 0.262,
          "positive": 0.687
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.008,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.004,
          "neutral": 0.981,
          "sadness": 0.001,
          "surprise": 0.002
        }
      },
      {
        "user": "SJDidge",
        "comment": "Cool project. Can you please give me the dumbed down explanation of what this is doing, or what it’s used for? I can’t really make sense of it. Iiuc, it seems to be a way of implementing an observer pattern?",
        "score": 1,
        "date": "2025-04-26T22:22:35",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.239,
          "neutral": 0.515,
          "positive": 0.247
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.213,
          "disgust": 0.329,
          "fear": 0.008,
          "joy": 0.001,
          "neutral": 0.353,
          "sadness": 0.053,
          "surprise": 0.043
        }
      },
      {
        "user": "rover_G",
        "comment": "What use cases are you targeting with this library?",
        "score": 1,
        "date": "2025-04-26T15:37:56",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.031,
          "neutral": 0.9,
          "positive": 0.069
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.006,
          "disgust": 0.002,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.929,
          "sadness": 0.0,
          "surprise": 0.059
        }
      },
      {
        "user": "Otherwise_Repeat_294",
        "comment": "As a manager if someone brings this as an alternative to the current systems he will be fired",
        "score": -5,
        "date": "2025-04-26T13:52:54",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.813,
          "neutral": 0.181,
          "positive": 0.006
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.088,
          "disgust": 0.012,
          "fear": 0.002,
          "joy": 0.002,
          "neutral": 0.891,
          "sadness": 0.003,
          "surprise": 0.001
        }
      },
      {
        "user": "gerardwx",
        "comment": "Well … no.\nYou’re missing docstrings and you have a lower case “signal” function which appears to do nothing but create a Signal class.\n\nThe concept isn’t that difficult… I’ve done it once or twice… and it’s not following Python conventions.",
        "score": -2,
        "date": "2025-04-26T17:52:37",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.349,
          "neutral": 0.484,
          "positive": 0.167
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.012,
          "disgust": 0.055,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.919,
          "sadness": 0.006,
          "surprise": 0.007
        }
      }
    ],
    "resumen_mt5": "In our series of letters from readers, we've been sharing a library that brings reactive programming to Python."
  },
  {
    "flair": "Discussion",
    "title": "Thoughts on adding a typing.EnumValues static typing primitive?",
    "author": "42696",
    "date": "2025-04-25T02:53:43",
    "score": 37,
    "description": "I recently had an issue I ran into and had an idea for what I feel would be a really helpful extension to typing, and I wanted to see if anyone else thinks it makes sense.\n\nI was writing a pydantic class with a string field that needs to match one of the values of an Enum. \n\nI could do something like `Literal[*[e.value for e in MyEnum]]`, dynamically unpacking the possible values and putting them into a Literal, but that doesn't work with static type checkers.\n\nOr I could define something separate and static like this:\n\n```\nclass MyEnum(str, Enum):\n    FIRST = \"first\"\n    SECOND = \"second\"\n\ntype EnumValuesLiteral = Literal[\"first\", \"second\"]\n```\n\nand use `EnumValuesLiteral` as my type hint, but then I don't have a single source of truth, and updating one while forgetting to update the other can cause sneaky, unexpected bugs.\n\nThis feels like something that could be a pretty common issue - especially in something like an API where you want to easily map strings in requests/responses to Enums in your Python code, I'm wondering if anyone else has come across it/would want something like that?\n\n\nEDIT: Forgot to outline how this would work ->\n\n```\nfrom enum import Enum\nfrom typing import EnumValues\n\n\nclass Colors(str, Enum):\n    RED = \"red\"\n    BLUE = \"blue\"\n    GREEN = \"green\"\n\n\nclass Button:\n    text: str\n    url: str\n    color: EnumValues[Colors]  # Equivalent to Literal[\"red\", \"blue\", \"green\"]\n```",
    "comments": [
      {
        "user": "beisenhauer",
        "comment": "There's no need for the additional literal type. You can just set the type in your Pydantic model to `Color`. You might need a bit of serialization logic, but Pydantic is pretty slick when it comes to handling enums.",
        "score": 40,
        "date": "2025-04-25T03:03:27",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.019,
          "neutral": 0.266,
          "positive": 0.716
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.005,
          "fear": 0.001,
          "joy": 0.004,
          "neutral": 0.985,
          "sadness": 0.002,
          "surprise": 0.001
        }
      },
      {
        "user": "Ok_Expert2790",
        "comment": "As other commenter said, Enums have built in pydantic support. Also, subclass StrEnum instead of str & enum",
        "score": 5,
        "date": "2025-04-25T03:36:45",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.046,
          "neutral": 0.81,
          "positive": 0.144
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.002,
          "fear": 0.0,
          "joy": 0.003,
          "neutral": 0.988,
          "sadness": 0.003,
          "surprise": 0.002
        }
      },
      {
        "user": "latkde",
        "comment": "I have missed exactly this feature (in a non-Pydantic-setting) recently. I ended up giving up, and using a literal type instead of enums (can still extract a list of all variants via `typing.get_args()`).\n\n\nHowever, I don't think there's substantial interest in defining more and more special forms. On the other hand, there's no systematic way to solve this because Python type expressions must also be valid runtime objects. C++ can have decltype and TypeScript can have projections due to having a compilation step (C++) or due to types having no runtime representation (TS). Python could get a good enough approximation by adding a nested type like `Color.Values`, except that this wouldn't work on unions like `(Color.RED | Color.BLUE).Values`.\n\n\nSo a special form like `EnumValues[T]` is indeed the only possible solution, but that's a lot of complexity for a fairly niche feature.",
        "score": 3,
        "date": "2025-04-25T06:59:08",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.45,
          "neutral": 0.442,
          "positive": 0.109
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.011,
          "disgust": 0.015,
          "fear": 0.0,
          "joy": 0.001,
          "neutral": 0.964,
          "sadness": 0.006,
          "surprise": 0.002
        }
      },
      {
        "user": "james_pic",
        "comment": "The API use case highlights a subtle problem: What's actually checking that these strings actually have one of these values? Static types are ignored at runtime, and if you've just received a value over the wire, you don't know it's one of these values. You're going to need some kind of runtime logic to validate this, and it might as well be the logic that turns it into an enum (which Pydantic supports reasonably well).\n\n\nI suspect that if you want this, then you probably have a layering problem.",
        "score": 3,
        "date": "2025-04-25T10:07:17",
        "sentiment": "negative",
        "sentiment_probs": {
          "negative": 0.62,
          "neutral": 0.341,
          "positive": 0.039
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.008,
          "disgust": 0.009,
          "fear": 0.001,
          "joy": 0.001,
          "neutral": 0.975,
          "sadness": 0.002,
          "surprise": 0.004
        }
      },
      {
        "user": "anentropic",
        "comment": "Just use the enum members directly instead of the string values",
        "score": 4,
        "date": "2025-04-25T08:00:58",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.198,
          "neutral": 0.747,
          "positive": 0.054
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.007,
          "disgust": 0.004,
          "fear": 0.0,
          "joy": 0.002,
          "neutral": 0.983,
          "sadness": 0.002,
          "surprise": 0.002
        }
      },
      {
        "user": "ShaunRW91",
        "comment": "Could you use StrEnum to achieve this?",
        "score": 3,
        "date": "2025-04-25T03:06:04",
        "sentiment": "neutral",
        "sentiment_probs": {
          "negative": 0.028,
          "neutral": 0.917,
          "positive": 0.056
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.003,
          "disgust": 0.0,
          "fear": 0.001,
          "joy": 0.003,
          "neutral": 0.982,
          "sadness": 0.001,
          "surprise": 0.01
        }
      },
      {
        "user": "mgrl85",
        "comment": "Pydantic also supports colors using the extra types package https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/",
        "score": 0,
        "date": "2025-04-25T03:56:49",
        "sentiment": "positive",
        "sentiment_probs": {
          "negative": 0.005,
          "neutral": 0.435,
          "positive": 0.56
        },
        "emotion": "neutral",
        "emotion_probs": {
          "anger": 0.002,
          "disgust": 0.001,
          "fear": 0.0,
          "joy": 0.004,
          "neutral": 0.99,
          "sadness": 0.001,
          "surprise": 0.002
        }
      }
    ],
    "resumen_mt5": "If you want to add a static type to your Python code, you might have been asked to explain why."
  }
]